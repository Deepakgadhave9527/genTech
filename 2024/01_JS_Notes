

//===========================this =========================

Q2. What is this?

In JavaScript, the `this` keyword refers to the current execution context.
Its value depends on how a function is called and where it is called.
The behavior of `this` can vary in different situations:

<!-- -The JavaScript this keyword refers to the object it belongs to. -->
-Alone, this refers to the  window object.
-In a normal function, this refers to the  window object.
-In a method, this refers to the owner object.
-Arrow functions do not have their own this context.
 Instead, they inherit this from the surrounding lexical scope (the context in which they are defined).


-In a function, in strict mode, this is undefined.
-In an event, this refers to the element that received the event.
-Methods like call(), and apply() can refer this to any object.


It has different values depending on where it is used:

1. Global context:
In the global scope, `this` refers to the global object, which is `window` in web browsers and `global` in Node.js.

console.log(this === window); // true in a browser environment


2. Function context: Inside a function, the value of `this` depends on how the function is called. If the function is called as a method of an object, `this` refers to that object.

const obj = {
name: 'example',
greet: function() {
console.log('Hello, ' + this.name);
}
};

obj.greet(); // Output: Hello, example


3. Constructor context: When a function is used as a constructor with the `new` keyword, `this` refers to the newly created instance.

function Person(name) {
this.name = name;
}

const person1 = new Person('John');
console.log(person1.name); // Output: John


4. Explicit binding: You can explicitly set the value of `this` using `call()`, `apply()`, or `bind()` methods.

function greet() {
console.log('Hello, ' + this.name);
}

const obj1 = { name: 'Alice' };
const obj2 = { name: 'Bob' };

greet.call(obj1); // Output: Hello, Alice
greet.apply(obj2); // Output: Hello, Bob

const greetBob = greet.bind(obj2);
greetBob(); // Output: Hello, Bob

<button id="myButton">Click Me</button>
<script>
  document.getElementById('myButton').addEventListener('click', function() {
    console.log(this); // Refers to the button element
  });

  document.getElementById('myButton').addEventListener('click', () => {
    console.log(this); // Refers to the global object or undefined (depending on the environment), not the button element
  });
</script>

========================== typeof ==================================

Q1: What is typeof operator?

JavaScript provides a typeof operator that can examine a value and tell you what type it is:
var a;
typeof a; // "undefined"


console.log(typeof undefined); // Output: "undefined"
console.log(typeof null);      // Output: "object"
console.log(typeof NaN);       // Output: "number"

let a;

a = "hello world";
console.log(typeof a); // "string"

a = 42;
console.log(typeof a); // "number"

a = true;
console.log(typeof a); // "boolean"

a = null;
console.log(typeof a); // "object" -- weird, bug

a = undefined;
console.log(typeof a); // "undefined"

a = { b: "c" };
console.log(typeof a); // "object"

a = [1, 2, 3];
console.log(typeof a); // "object"
console.log(Array.isArray(a)); // true

<!-- The typeof operator for arrays returns "object" because arrays are a special type of object in JavaScript.
 If you want to specifically check if a variable is an array, you can use  -->

function greet(name) {
    return "Hello, " + name + "!";
}
console.log(typeof greet); // "function"

const greetExpression = function(name) {
    return "Hello, " + name + "!";
};
console.log(typeof greetExpression); // "function"

const greetArrow = (name) => {
    return "Hello, " + name + "!";
};
console.log(typeof greetArrow); // "function"



========================== Prototype ==================================
Prototype:-

-Prototypes are the mechanism by which JavaScript objects iinherit properties and method from one another.
- Every object in JavaScript has a prototype,

 which is another object that provides shared properties and methods.
 -Javascript is a Prototype based language.

When to Use Prototypes?
Prototypes are used to share methods and properties across multiple instances efficiently.
They avoid duplicating properties or methods for each instance, saving memory.

There are two main ways to set the prototype of an object:

1. By using `__proto__`
   - The `__proto__` property can be used to directly set the prototype of an object.
   let animal = { eats: true };
   let rabbit = { jumps: true };
   rabbit.__proto__ = animal; // Setting the prototype
   console.log(rabbit.eats); // Output: true
   

2. By using `Object.setPrototypeOf()`
   - The `Object.setPrototypeOf(obj, prototype)` method sets the prototype of `obj` to `prototype`.
   let animal = { eats: true };
   let rabbit = { jumps: true };
   Object.setPrototypeOf(rabbit, animal); // Setting the prototype
   console.log(rabbit.eats); // Output: true




### Types of Prototypes in JavaScript


Object Prototype
Function Prototype
Prototype Chain

1. Object Prototype

-Every JavaScript object has an internal link to another object called its prototype.
                     
  -This prototype object can also have its own prototype, creating a prototype chain.
   - Every object has a prototype, from which it inherits properties and methods.
   - Access via `Object.getPrototypeOf(obj)` or `obj.__proto__`.

   let obj = {};
   console.log(obj.__proto__); // Output: {}
   

2. Function Prototype
   - Functions have a `prototype` property used when creating objects with `new`.
   - Example:
       function Person(name) {
         this.name = name;
     }
     Person.prototype.greet = function() {
         console.log('Hello, ' + this.name);
     };
     let alice = new Person('Alice');
     alice.greet(); // Output: Hello, Alice
     

3. Prototype Chain
   If a property or method is not found on an object, JavaScript looks for it up the prototype chain until it either finds it or reaches the end (null).

   - Objects inherit properties and methods from their prototype, forming a chain.
   - Example:
       let animal = { eats: true };
     let rabbit = { jumps: true };
     rabbit.__proto__ = animal;
     console.log(rabbit.eats); // Output: true


     
======================= Prototype vs __proto__ ==================================


### prototype:

- Defines properties and methods for constructor functions.
- Exists only on functions (constructor functions).
- Used for inheritance in object creation with new.

### __proto__:

- Accesses or sets the prototype of individual objects.
- Exists on all objects.
- Used for dynamic prototype handling.


prototype is used to define properties and methods for constructor functions.
prototype exists only on functions (specifically, constructor functions).

__proto__ is used to access or set the prototype of an individual object.
__proto__ exists on all objects.


========================================================================
 difference between `__proto__` and `Object.setPrototypeOf()` 

### **By using `__proto__`**
- Introduced in early JavaScript implementations (pre-ES3).
 - Legacy, deprecated, and slower.
  - Still supported for backward compatibility.
  - Simple but not suitable for modern applications.


### **By using `Object.setPrototypeOf()`**
- Introduced in **ECMAScript 2015 (ES6)**.
-  **`Object.setPrototypeOf()`**:
  - Modern, standardized, and better optimized.
  - Recommended for modern JavaScript and production environments. 


//==============================JavaScript Use Strict=========================

purpose of "use strict" is to indicate that the code should be executed in "strict mode".
With strict mode, you can
not, use undeclared variables.

Certainly! Heres a list of key restrictions and changes applied by `"use strict"` in JavaScript:

1. Eliminates `this` coercion
2. Disallows undeclared variables
3. Disallows duplicate parameter names
4. Disallows `with` statements
5. Disallows octal literals
6. Disallows `eval` from modifying scope
7. Disallows `delete` on variables and functions
8. Requires unique function parameter names
9. `arguments` object is not linked to parameters
10. Prohibits `getter` and `setter` methods with the same name
11. Avoids silent errors
12. No `this` binding in class methods
13. Disallows future reserved keywords


=================================================================================================================
let and const var keywords

In javascript to declare a variable you can use 'var' keyword, but since ES6 there are 2 more keywords
introduced to declare the variables.


--------------------------------------------------------------------
### var
- it is hoisted
- It is function scoped
- It  rewritable
- Can be redeclared within the same scope



- It  rewritable
var x = 10;
x = 20; // Valid: Updates the value of x

- Can be redeclared within the same scope
var x = 5;
var x = 10;


var declarations are hoisted to the top of their scope (global or function) Only the declaration is hoisted, not the initialization. 



### ✅ **30-Second Summary for `var`:**

`var` is function-scoped and hoisted to the top of its function or global scope, but initialized as `undefined`. we can both reassign and redeclare `var` variables in the same scope, which can lead to bugs. It's not block-scoped, so variables declared inside `if` or `for` blocks are still accessible outside, which is one reason it's less preferred today.





--------------------------------------------------------------------

### let:-

- It is not hoisted
- It is block scoped
- It is rewritable
- Cannot be redeclared within the same block scope


let y = 10;
y = 20; // Valid: Updates the value of y


- Cannot be redeclared within the same block scope
let y = 5;
let y = 10; // SyntaxError: Identifier 'y' has already been declared


### ✅ **30-Second Summary for `let`:**

`let` is block-scoped and hoisted, but not initialized — so using it before declaration causes a ReferenceError due to the Temporal Dead Zone. It allows reassignment but not redeclaration in the same block. Because of its predictable scoping and safer behavior, `let` is generally preferred over `var`.


--------------------------------------------------------------------


const is hoisted, but it's not initialized, which means it’s in the Temporal Dead Zone until its declaration is reached.

### const:-
- It is not hoisted
- It is block scoped
-const is not  rewritable
- Cannot be redeclared within the same block scope


const creates an immutable binding, meaning the variable identifier cannot be reassigned to a new value; however, if the value is an object or array, the contents of that object or array can still be modified.

-const is not  rewritable
const x = 10;
x = 20; //  TypeError: Assignment to constant variable.

-Cannot be redeclared within the same block scope
const z = 5;
const z = 10; // SyntaxError: Identifier 'z' has already been declared


hoisting error
ReferenceError: Cannot access 'a' before initialization

### ✅ **30-Second Summary for `const`:**

`const` is block-scoped, like `let`, and it's hoisted but not initialized — so accessing it before declaration throws a ReferenceError due to the Temporal Dead Zone. You can't reassign or redeclare a `const` variable in the same scope. However, if it's assigned an object or array, the reference stays constant, but the internal contents can still be modified. So, `const` protects the reference, not the data inside non-primitives.




-----------------------------------------------------------------

For primitives, 
const makes the value itself immutable and the reference unchangeable.

For non-primitives, 
const makes the reference unchangeable, but the contents of the object or array can still be modified.

===============================================================================================


# Understanding `const` vs Immutability in JavaScript

## What `const` Actually Does

* **Prevents reassignment** of the variable identifier.
* **Does NOT make the value immutable**.

---

## Immutable vs Mutable Values

### Immutable

* Cannot be changed after creation.
* Examples include **primitive types**:

  * `String`
  * `Number`
  * `Boolean`
  * `null`
  * `undefined`
  * `BigInt`
  * `Symbol`

### Mutable

* Can be changed after creation.
* Examples include:

  * `Objects`
  * `Arrays`
  * `Functions`

---

## Examples to Illustrate the Difference

### Example 1: `const` with a Primitive (Immutable) Value

```js
const greeting = "Hello";
greeting = "Hi"; // ❌ Error: Assignment to constant variable
```

* `"Hello"` is a **string**, which is immutable.
* `greeting` is declared with `const`, so reassignment is disallowed.
* You **cannot** reassign `greeting` to a new string.

---

### Example 2: `const` with an Object (Mutable Value)

```js
const person = { name: "Alice" };
person.name = "Bob"; // ✅ Allowed
console.log(person.name); // "Bob"

person = { name: "Charlie" }; // ❌ Error: Assignment to constant variable
```

* `person` is a `const` variable, so **you cannot reassign the variable** to a new object.
* However, the **object itself is mutable**, so you can change its properties.
* Mutating the content is allowed, but reassigning the variable is not.

---

### Example 3: `let` with an Array (Mutable Value)

```js
let nums = [1, 2, 3];
nums.push(4); // ✅ Allowed - modifies the original array
console.log(nums); // [1, 2, 3, 4]

nums = [5, 6]; // ✅ Allowed - reassignment is allowed with let
console.log(nums); // [5, 6]
```

---

## Summary

| Concept          | What `const` Does             | Mutability of Value                      |
| ---------------- | ----------------------------- | ---------------------------------------- |
| `const` variable | Prevents reassignment         | Value can be mutable or immutable        |
| Immutable values | Primitives (strings, numbers) | Value itself cannot be changed           |
| Mutable values   | Objects, arrays, functions    | Their contents/properties can be changed |
===============================================================================================


//========== primitive vs reference variable=================


### **Primitive Data Types:**
1. String
2. Number
3. BigInt
4. Boolean
5. undefined
6. null
7. Symbol

### **Non-Primitive (Reference) Data Types:**
1. Object
2. Array
3. Function
4. Date
5. RegExp

## A] primitive variables:

-primitive variables are used to store primitive values

- Copy behavior: When you assign a primitive value to another variable, a copy of the value is created.

// primitive variables
let a = 10;
let b = a;
a = 20;

console.log(a); //20
console.log(b); //10


## B] reference variables:
- Stored as references
 - The variable holds a reference (or pointer) to the location in memory where the object is stored.

-When you assign a reference variable to another, both variables point to the same object. 

When you assign a reference variable to another variable in JavaScript, both variables point to the same object in memory. So, if you change the object using the second variable, those changes will also be visible when accessing the object through the first variable.

var x = { name: "abcd" };
var y = x;
x.name = "pqr";
console.log(x.name); //pqr

 <!-- Primitive Types:
These are basic data types like string, number, boolean, null, undefined, symbol, and bigint.

-When you assign a primitive value to a variable, the value is stored directly in the variable's memory location. If you assign that variable to another variable, the value is copied, and each variable will have its own copy of that value.

- both variable have differnt memory location
-The value of a primitive is stored in a stack memory.

let a = 42;  // `a` stores the value 42
let b = a;   // `b` now stores the value 42 (copy of `a`)

b = 100;     // Change `b`, but `a` remains 42

console.log(a);  // 42
console.log(b);  // 100
ere, a holds the value 42. When a is assigned to b, a new copy of the value 42 is created for b. Therefore, changing b does not affect a.


Reference Types (By Reference)
-These include objects (including arrays, functions, and others).
-when a non-primitive (reference) value is assigned to another variable, the reference (memory address) to the object is copied, not the actual object itself. This means both variables will point to the same object in memory, and changes made to the object via one variable will be reflected when accessed via the other variable.

- both variable have same memory location


-Reference types are typically stored in heap memory. 


let obj1 = { name: "Alice", age: 30 };  // `obj1` is an object
let obj2 = obj1;  // `obj2` gets the **reference*- to the same object as `obj1`

obj2.age = 31;    // Changing `age` via `obj2`

console.log(obj1.age);  // 31 (since both `obj1` and `obj2` point to the same object)
console.log(obj2.age);  // 31 (both variables reflect the same object)
 -->

Got it! Here's your document without the "Summary of Differences" section:

### **Primitive Types:**

These are the basic data types in JavaScript:
- `string`
- `number`
- `boolean`
- `null`
- `undefined`
- `symbol`
- `bigint`

**Key Characteristics:**
- When you assign a primitive value to a variable, the value is stored **directly** in the variable's memory location. If you assign that variable to another, the **value is copied**—each variable has its own copy.
- Both variables have **different memory locations**.
- The value of a primitive is stored in **stack memory**.

**Example:**
```javascript
let a = 42;  // `a` stores the value 42
let b = a;   // `b` now stores a copy of the value 42

b = 100;     // Changing `b` doesn't affect `a`

console.log(a);  // 42
console.log(b);  // 100
```
In this case, `a` holds 42, and when it's assigned to `b`, a copy of 42 is created for `b`. Changing `b` does not affect `a`.

### **Reference Types:**

These include objects (arrays, functions, and other objects).

**Key Characteristics:**
- When a reference type is assigned to a variable, the **reference (memory address)** to the object is copied, not the actual object itself. Both variables will point to the same object in memory.
- Both variables have **the same memory location**.
- Reference types are typically stored in **heap memory**.

**Example:**
```javascript
let obj1 = { name: "Alice", age: 30 };  // `obj1` is an object
let obj2 = obj1;  // `obj2` holds the reference to the same object

obj2.age = 31;    // Changing `age` via `obj2`

console.log(obj1.age);  // 31
console.log(obj2.age);  // 31
```
In this example, both `obj1` and `obj2` point to the same object. Modifying the object through one reference affects the other, since they both refer to the same memory location.

Let me know if you need anything else!

when variable primative value  assignt to another varilble that time value will be copy/assigned 
when variable not primative value assigned to anoter variable that time memory refrance will be assigne 




 ===============================================================================================

* **`let` and `const` are hoisted**, but **not initialized** until their declaration is executed. Accessing them before that causes a **ReferenceError** due to the Temporal Dead Zone (TDZ).

* **`var` is hoisted and initialized with `undefined`** immediately, so you can access it before the declaration without an error (it will just be `undefined`).


//============================ Temporal Dead Zone (TDZ)=============================

Temporal Dead Zone (TDZ): 


The **Temporal Dead Zone (TDZ)** is this **time period** (or “zone”) from the **start of a block scope** until the **variable declared with `let` or `const` is initialized**.

During the TDZ:

* The variable **exists** (it’s hoisted),
* But **cannot be accessed**,
* Attempting to access it throws a **ReferenceError**.


### Visualizing TDZ with an example:

```js
{
  // TDZ starts here for 'x'
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  
  let x = 5; // TDZ ends here (x is initialized)
  console.log(x); // 5 (now accessible)
}
```

---

### Key points:

* TDZ applies **only** to variables declared with `let` and `const`.
* `var` declarations do **not** have TDZ because they are initialized with `undefined` immediately.






 The time period between the start of a block scope and the point where a variable declared with let or const is initialized. During this zone, the variable exists but cannot be accessed, and attempts to do so result in a ReferenceError.

let and const Hoisting:
Variables declared with let and const are hoisted to the top of their block scope but are not initialized during hoisting. Accessing them before the declaration results in a ReferenceError due to the TDZ..

=============================================================================================================
lexical scope

When a function (Function B) is declared inside another function (Function A), JavaScript uses lexical scoping to determine what variables Function B has access to.
// 🌍 Global scope
let globalVar = "I am global";

function Function_A_outer() {
  // 🔹 Lexical Scope Level 1 (outer)
  let outerVar = "I am outer";

  function Function_b_inner() {
    // 🔸 Lexical Scope Level 2 (inner)
    let innerVar = "I am inner";

    // ✅ Accessing variables through lexical scope
    console.log(globalVar); // ← from Global Scope
    console.log(outerVar);  // ← from outer()'s Lexical Scope
    console.log(innerVar);  // ← from inner()'s own scope
  }

  Function_b_inner(); // Call the inner function
}

Function_A_outer(); // Call the outer function


//================================= Closure ========================


## ✅ **JavaScript Closures & Lexical Scope – Interview Notes**

### 🔹 **Definition of Closure:**
> A closure in JavaScript is a function bundled together with its lexical environment

> It allows an inner function to **access variables** from an outer function’s scope **even after** the outer function has finished executing.

> A **closure** is the combination of a **function** and the **lexical environment** in which it was defined.


### 🔹 **Key Points to Remember:**

* Closures enable **data privacy** and **state persistence**.
* Variables in the outer scope are **held by reference**, not by value.
* The inner function **always accesses the latest value** of those variables.
* **Lexical scope** means scope is determined by **where code is written**, not where it’s called.



### 🔹 **Simple Closure Example:**

```javascript
function outerFunction() {
  let outerVariable = 'I am outer';
let a=20
  function innerFunction() {
    console.log(outerVariable); // Accesses outerVariable via closure
        console.log(a); // Accesses outerVariable via closure

  }
a=30;
  return innerFunction;
}

const innerFunc = outerFunction();
innerFunc(); // Output: outerVariable = I am outer and a=30
 
```

---

### 🔹 **Real-World Use Case – Counter:**

```javascript
function createCounter() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

> `count` is private and persistent across function calls due to closure.

When function_a_outer is executed, function_b_inner still retains access to its lexical scope. These variables are held by reference, not as the original values at definition time. As a result, the inner function always accesses the latest value of those variables



When a customer visits an online store:

A new shopping cart is created (via a function).

The cart has a private list of items, not accessible directly from outside.

The cart exposes functions to:

✅ Add items

❌ Remove items

👁️ View cart contents

These functions are closures — they retain access to the private list of items, even after the main cart function has executed.


--------------------------------------------------------------------------

- When a customer visits an online store, a new shopping cart is created.
- This cart contains a private list of items, inaccessible directly from outside.
- To manage the cart, specific functions are provided:
  - One for adding items.
  - One for removing items.
  - One for viewing the cart's contents.
- These functions can access the private list, even though it's hidden from the outside.
- When a customer adds an item:
  - The function modifies the private list to include the new item.
- When a customer removes an item:
  - Another function checks the list and updates it accordingly.
- To view the cart:
  - A function reads and displays the list without changing it.
- This use of closures ensures that the cart’s internal list remains encapsulated and secure, only modifiable through the designated functions.
- The private list retains its state throughout the customer’s session because the functions maintain a reference to it.
- This encapsulation:
  - Enhances security by preventing direct tampering.
  - Ensures that each customer's cart operates independently and consistently throughout their shopping experience.

<!-- 
Certainly! Here's a concise explanation using a continuous format:

When a customer visits an online store, a new shopping cart is created. This cart contains a private list of items, inaccessible directly from outside. To manage the cart, specific functions are provided: one for adding items, one for removing items, and one for viewing the cart's contents. These functions can access the private list, even though it's hidden from the outside. When a customer adds an item, the function modifies the private list to include the new item. When they remove an item, another function checks the list and updates it accordingly. To view the cart, a function reads and displays the list without changing it. 

This use of closures ensures that the cart’s internal list remains encapsulated and secure, only modifiable through the designated functions. The private list retains its state throughout the customer’s session because the functions maintain a reference to it. This encapsulation enhances security by preventing direct tampering and ensures that each customer's cart operates independently and consistently throughout their shopping experience. -->


=============================================================================================================

Object destructuring:-

> Object destructuring is used to declare and initialzize variables by extracting the values from object properties.

> Object destructuring is a JavaScript syntax that allows you to extract values from an object and assign them to variables in a concise and readable way.


const person = {
name: "Topper Skills",
mobile: "7875580668",
email: "topperskills@gmail.com",
city: "Pune",
};

### without Object destructuring

const phone = person.mobile;
const email = person.email;
const city = person.city;

### with Object destructuring
Property name and variable name must be same

const { mobile: phone, email, city } = person;
console.log(phone, email, city);


### Destructuring Nested Properties

const car = {
brand: "Hyundai",
model: "Verna",
info: {
price: 1200000,
color: "white",
bio:{
age:20
}
}
}


const {info:{bio:{age}}}=car
console.log(age)//20

const {info:{bio:{age:age3}}}=car
console.log(age3)//20


Why use it?

Avoid repetitive code like const name = person.name;

Make your code cleaner and easier to understand

Easily extract multiple properties in one statement



### 🔧 **Common Use Cases of Object Destructuring:**

1. **Accessing object properties quickly**
   → Avoid repetitive `obj.prop` syntax.

2. **Function parameters**
   → Pass an object, extract only needed values:

   ```js
   function greet({ name }) { console.log(name); }
   ```

3. **API responses**
   → Extract nested data directly from response objects.

4. **Set default values**
   → Provide fallback if a property is missing:

   ```js
   const { theme = 'light' } = settings;
   ```

5. **React components**
   → Destructure props for cleaner JSX:

   ```js
   function Card({ title, content }) { ... }
   ```



====================================================================================================

// Array Destructuring:-

const nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

const a = nums[0];
const b = nums[1];
const c = nums[2];
const d = nums[4];
with destructuring

const [a, b, c, d] = nums;

console.log(a, b, c, d);

const nestedArray = [1, [2, 3, 7], [4, [5, 6]]];

const [first, [, third], [fourth, [fifth, sixth]]] = nestedArray;

console.log(first); // 1
console.log(third); // 3
console.log(fourth); // 4
console.log(fifth); // 5
console.log(sixth); // 6


//============================Object.keys, values, entries =============


### 📌 1. **`Object.keys(obj)`**

🔹 Returns an **array of the property names (keys)** of the object.

```javascript
const user = { name: 'Alice', age: 25 };

console.log(Object.keys(user)); 
// ➝ ['name', 'age']
```


### 📌 2. **`Object.values(obj)`**

🔹 Returns an **array of the property values**.

```javascript
console.log(Object.values(user)); 
// ➝ ['Alice', 25]
```


### 📌 3. **`Object.entries(obj)`**

🔹 Returns an **array of key-value pairs** as arrays.

```javascript
console.log(Object.entries(user)); 
// ➝ [['name', 'Alice'], ['age', 25]]
```

You can use `.map()`, `.forEach()`, or a `for...of` loop on them too.


### ✅ Use cases:

* Looping through objects
* Converting objects to arrays (for filtering, mapping, etc.)
* Working with dynamic object data (e.g., from APIs)




//=================================Spread operator==========================

Spread operator:-
The spread operator (...) in JavaScript is used to extract elements from an iterable (such as an array or object) and spread them into individual elements or properties. 

It allows for easier cloning, merging, and destructuring of arrays and objects.

It is used to extract elements of an array or to extract properties from an iterable object.

const arr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

console.log(...arr);

const per = {
name: "TOpper Skills",
mobile: "7875580668",
email: "topperskills@gmail.com",
};
const iterObj = Object.keys(per);
console.log(...iterObj);\\name mobile email





1 Copy arrays or objects
2 Merge arrays or objects
3 Add elements to arrays
4 Pass array items as function arguments
5 Convert iterables to arrays



======================================Rest operator:-========================


Rest operator:-
-The rest operator is used to store all the arguments which do not have matching parameters.
-The rest is an array.
-Rest operator basic help to pass infinite number of argument in a function

Example:

function add(a, b, ...args) {
console.log(a, b);
console.log(args);
}

add(10, 20);
add(10, 20, 30, 40, 50);

function greet(name) { // 'name' is a parameter
    console.log('Hello, ' + name);
}

greet('Alice'); // 'Alice' is an argument


function sum(a, b) {  // 'a' and 'b' are parameters
  return a + b;
}

console.log(sum(5, 10));  // '5' and '10' are arguments



//============================ arguments object vs rest perator===================================

##= arguments object vs rest operator =##

-Arguments is an object.
-rest is an array

-Arguments gives the details of a function call including caller, callee, arguments.
-Rest operator does not give details about the function call, it gives only the arguments which do not have
matching parameters

-Arguments object gives all the arguments despite those arguments have matching parameters or not
-Rest oeprator does not give the arguments which have matching parameters

-The arguments object is built-in
-The rest operation is not built, you need to declare it after all the parameters of a function



//============================== Noraml function vs arrow function =========================


### When to use which function (best practices)

Use arrow functions for callbacks, array methods, or when you want to inherit this.
Use normal functions for constructors, class/object methods, or when you need this, arguments, or super.

-Arrow functions don’t have their own this. They inherit it from the parent scope. So inside an object, this won’t refer to the object.


--------------------------------------------------

A]Noraml function

> this value inside a regular function is dynamic and depends on the invocation.
> Noraml functions created using function declarations or expressions

> Noraml functions are constructible, invoked with the new keyword
> Noraml functions used have duplicate named parameters

> Normal function declarations are hoisted, meaning they can be called before they are defined in the code.

>  Normal functions have an arguments object that holds all passed arguments.


B]Arrow function

-Arrow functions do not have their own this context.
 Instead, they inherit this from the surrounding lexical scope (the context in which they are defined).

-arrow function cannot be used as a constructor. NOT invoked with the new keyword

-Arrow functions can never have duplicate named parameters, whether in strict or non-strict mode.
-Arrow function is Not hoisted

- Arrow functions don’t have their own arguments object. Use rest parameters (...args) to get all arguments.


-Arrow function — also called fat arrow function

-Curly brackets arent required if only one expression is present.
let add = (x, y) => x + y;

-If theres only one argument, then the parentheses are not required either:
let squareNum = x => x * x;

arrow functions do not have their own this value.
Instead, they inherit the this value from the enclosing lexical scop


//============================== call,apply,bind =========================



**A] call():**

- Call method is predefined method in JavaScript
- An object can use a method belonging to another object
- call method is Immediately invokes a function with a given `this` value and arguments provided individually

- accepts arguments as separate values

```js
var employee1 = {firstName: 'John', lastName: 'Rodson'};
var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

function invite(greeting1, greeting2) {
  console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', ' + greeting2);
}

invite.call(employee1, 'Hello', 'How are you?'); // Hello John Rodson, How are you?
invite.call(employee2, 'Hello', 'How are you?'); // Hello Jimmy Baily, How are you?


var employee1 = {
  firstName: 'John',
  lastName: 'Rodson',
  invite: function(greeting1, greeting2) {
      console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName + ', ' + greeting2);
  }
};

var employee2 = {
  firstName: 'Jimmy',
  lastName: 'Baily'
};

employee1.invite.call(employee2, "Hello", "World"); // Hello Jimmy Baily, World
```



**B] apply():**

- apply() method is similar to call() method
- call method argument takes separately
- apply method argument takes as an array
- invoke the function with a given this value and arguments provided by an array
- accepts arguments as array elements

```js
var employee1 = {firstName: 'John', lastName: 'Rodson'};
var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

function invite(greeting1, greeting2) {
  console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', ' + greeting2);
}

invite.apply(employee1, ['Hello', 'How are you?']); // Hello John Rodson, How are you?
invite.apply(employee2, ['Hello', 'How are you?']); // Hello Jimmy Baily, How are you?
```



**C] bind():**

- bind() method we can bind an object to a common function so that the function gives different result when it needs

- bind() returns a new function with a fixed this context and optional preset arguments, but doesn't invoke it immediately.

- bind method takes an object as the first argument and creates a new function
- bind **does not invoke the function immediately*- (unlike call or apply)  // added for clarity
- return a new function, allow you to pass any number of arguments
- it binds a function with an object and returns the bound function
- it does not bind the existing function, instead it creates a new function to bind // added for clarity

```js
var employee1 = {firstName: 'John', lastName: 'Rodson'};
var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

function invite(greeting1, greeting2) {
  console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', ' + greeting2);
}

var inviteEmployee1 = invite.bind(employee1);
var inviteEmployee2 = invite.bind(employee2);

inviteEmployee1('Hello', 'How are you?'); // Hello John Rodson, How are you?
inviteEmployee2('Hello', 'How are you?'); // Hello Jimmy Baily, How are you?
```

```js
const person = {
  firstName: 'John',
  lastName: 'Doe',
  fullName: function() {
      return this.firstName + ' ' + this.lastName;
  }
};

const printFullName = person.fullName;

// console.log(printFullName()); // Output: "undefined undefined" because `this` is lost

const boundPrintFullName = printFullName.bind(person);
console.log(boundPrintFullName()); // Output: "John Doe"
```
========================================================================


- A common use case for the `bind` method in JavaScript is to maintain the correct context (`this`) when passing methods as callbacks or event handlers.
- In JavaScript, the value of `this` can change depending on how a function is called.
- For instance, when a method is used as an event handler, `this` usually refers to the element that triggered the event, not the object that owns the method.
- By using `bind`, you can create a new function where `this` is explicitly set to the desired context, ensuring that the method behaves correctly regardless of how it's called.

- This is particularly useful in scenarios such as object-oriented programming and event handling, where preserving the context is crucial for the method's functionality.
- `bind` can also be used to preset initial arguments, allowing partial application of functions.



### 1. Plain JavaScript Event Handling with `bind`



**Interview Answer:**

> In JavaScript, the value of `this` depends on how a function is called, which can lead to unexpected behavior when passing methods as callbacks or event handlers. The `bind` method fixes this by creating a new function with `this` explicitly set to the desired object. This ensures the method retains the correct context regardless of how or where it’s called, which is especially useful in event handling and object-oriented programming.

```javascript

const user = {
  name: 'John',
  sayHello: function(greeting) {
    console.log(greeting + ', ' + this.name);
  }
};

const button = document.getElementById('myBtn');

// Without bind - `this` refers to button, not user
button.addEventListener('click', user.sayHello); // this.name is undefined

// With bind - `this` fixed to `user`
button.addEventListener('click', user.sayHello.bind(user, 'Hello')); 
// Output on click: "Hello, John"
```


In summary:
- `bind` creates a new function for later use, while `call` and `apply` execute the function immediately.
- `call` takes arguments individually, whereas `apply` takes arguments as an array.

------------------------------------------------------------------------------

### 2. React Class Component Event Handler with `bind`



**React.js Interview Answer:**

> In React class components, event handler methods lose their class instance context (`this`) when passed as callbacks. Using `bind` in the constructor or inline fixes this by explicitly setting `this` to the component instance. This ensures methods can access component state and props correctly during events, preventing common bugs related to `this` being `undefined` or incorrect.


```jsx
import React from 'react';

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };

    // Bind the event handler to fix 'this' context
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // Accessing this.state and this.setState works because of bind
    this.setState({ count: this.state.count + 1 });
    console.log('Count is:', this.state.count + 1);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me ({this.state.count})
      </button>
    );
  }
}

export default MyComponent;

```



In React class components, event handler methods don’t automatically bind `this` to the component instance. To fix that, we usually bind methods to `this` so they work correctly when called, especially as event handlers.

The most efficient way to bind is in the **constructor**, where the binding happens once when the component is created. This avoids creating new functions on every render, improving performance and preventing unnecessary re-renders.

Alternatively, using **arrow functions as class properties** automatically binds `this` and offers cleaner syntax, which is common in modern React code.

Binding inside `render()` is discouraged because it creates a new function every time the component re-renders, which hurts performance.














================================== Object cloning=============================================



-Crreating a duplicate object of an existing object is called object cloning
There are 2 types of object cloning

### **Shallow Cloning**  

Shallow cloning Only the top-level properties of an object are cloned it does not clone nested objects — it only copies their references. This means that if you change a nested object property in either the original or the clone, the change will affect both, because they both point to the same reference object.

To avoid unexpected bugs, don’t modify nested data in a shallow clone if you want the original unchanged. For full independence, use **deep cloning**, which copies all nested structures as well.

- Examples: `Object.assign()`, Spread operator (`...`).  


```javascript

const original = {
  name: "Alice",
  address: {
    city: "New York"
  }
};


const clone1 = Object.assign({}, original);//Using Object.assign()

const clone2 = { ...original };// Using Spread operator

clone1.address.city = "Los Angeles";

console.log(original.address.city); // Outputs: "Los Angeles" — nested object is shared
console.log(clone2.address.city);   // Outputs: "Los Angeles" — nested object is shared

//This happens because original.address.city and clone.address.city point to the same object in memory.

console.log(clone1 === original);        // false — different top-level objects
console.log(clone1.address === original.address); // true — nested object shared (same reference)

```

**Shallow cloning copies only the top level; nested objects are shared.**


- Copies only the top-level properties of an object.  
- Nested objects or arrays are **referenced**, not cloned.  
- Changes in nested structures reflect in both original and cloned objects.  

-In shallow cloning only direct/main object gets cloned but not the object
which are referred by the properties of main object.

-changing value of cloned object will be refect into
orginal object as well because both are point same refrance object

-----------------------

### **Deep Cloning**  
-In deep cloning all the object direct/main and nested objects will be cloned. Menas all parts of the object are fully cloned.
if you change a nested object property in either the original or the clone, the change will not affect both, because they both point to the different reference object.
- Nested objects or arrays are **independent** from the original.  


- Examples: `JSON.parse(JSON.stringify())`, Better Alternative – structuredClone() (modern built-in method),  Lodash's `cloneDeep()`, Recursive cloning.  


```javascript

const original = {
  name: 'John',
  age: 30,
  address: { city: 'New York', country: 'USA' }
};

const deepClone = JSON.parse(JSON.stringify(original));
const structuredCloneDeep = structuredClone(original);

console.log(deepClone === original); // false (different objects)
console.log(deepClone.address === original.address); // false (different objects)


```



**Shallow cloning** copies only the top-level properties of an object. Nested objects or arrays are shared by reference between the original and the clone. This means if you change a nested object in the clone, it also changes the original. To avoid unexpected bugs, don’t modify nested data in a shallow clone if you want the original unchanged. For full independence, use **deep cloning**, which copies all nested structures as well.

**Deep cloning** creates a complete, independent copy of an object, including all nested objects and arrays. Unlike shallow cloning, changes to nested structures in the clone do not affect the original. Common ways to deep clone in JavaScript include using JSON.parse(JSON.stringify(object)) for simple data or structuredClone(object) in modern environments. Deep cloning helps avoid bugs caused by shared references in nested objects.



================================== Object cloning =============================================

### ❌ **Limitations of `JSON.parse(JSON.stringify())`:**

It **fails to clone**:

* ✅ **Functions** → ❌ Removed
* ✅ **`undefined`** → ❌ Removed
* ✅ **`Date`** → ❌ Becomes string
* ✅ **`Map`, `Set`** → ❌ Lost (converted to empty objects or discarded)
* ✅ **Circular references** → ❌ **Throws error**

---

### ⚠️ Example:

```js
const obj = {
  date: new Date(),
  sayHi: () => console.log("Hi"),
  nested: undefined,
  today: new Date(),
  map: new Map(),
  set: new Set()
};

const clone = JSON.parse(JSON.stringify(obj));
console.log(clone);


### 🔍 Output:

{
  date: "2025-08-17T12:34:56.789Z",  // Date becomes string
  today: "2025-08-17T12:34:56.789Z", // Another string
  // sayHi is missing
  // nested is missing
  // map and set are missing
}
```


### ✅ Use `structuredClone()` instead for deep cloning with full support.


### ✅ **structuredClone Supports:**

* Primitives: `null`, `undefined`, numbers, strings, etc.
* Objects & Arrays
* Dates, Maps, Sets
* TypedArrays, ArrayBuffer
* RegExp, Error objects
* Blobs, Files, ImageData
* **Circular references**

### ❌ **Not Supported:**

* **Functions**
* **DOM elements**
* **SharedArrayBuffer**

---

### ✅ Example:
```js

const obj = {
  primitiveNull: null,
  primitiveUndefined: undefined,
  number: 42,
  string: "hello",
  boolean: true,
  bigint: 12345678901234567890n,

  object: { x: 10 },
  array: [1, 2, 3],

  date: new Date(),
  map: new Map([["key1", "value1"]]),
  set: new Set([1, 2, 3]),

  typedArray: new Uint8Array([10, 20, 30]),
  arrayBuffer: new ArrayBuffer(8),

  regexp: /abc/i,
  error: new Error("Something went wrong"),

  blob: new Blob(["Hello"], { type: "text/plain" }),
  file: new File(["Content"], "example.txt", { type: "text/plain" }),

  // Circular reference
  get circular() {
    return this;
  }
};

const cloned = structuredClone(obj);

console.log(cloned);
```

- Copies all levels of an object, including nested structures.  
- Changes in the clone do not affect the original object.  

-changing value of cloned object will be not refect into
orginal object as well because both are point different refrance object


//=============================sync and asynch=================


Note:- Javascript is a Synchronous programming language.

Javascript is single threaded.

But the execution environment of the Javascript is asynchronous.

// synchronous execution

How does javascript code gets executed asynchronously when there is one thread?

=> Javascript is single threaded, synchronous but the environment in which the javascript
code gets executed is asynchronous.

The javascript runtime(event loop) performs non blocking IO operations by offloading most of the work
to operating system.
/
/callback

// To write async code you need

1. callback

A callback is a normal javascript function which is passed as an argument to
another function to perform future operation.

A callback is used to perform any future operation after an asynchronous operation.


// 2. Promise

// 3. async await



//== ==============================Higher Order function :-==============================
Higher Order function :-

A higher order function is a function that takes one or more functions as arguments, or returns a function as its result.

A function which accepts another function as an argument is called a higher
order function.
The higher order function is used to perform different operations.

Example: addEventListener

Other Common Higher-Order Functions:
map()
filter()
reduce()
forEach()
setTimeout() and setInterval()


//=================== promise =============================



callback
callback is a function passed as an argument to another function,
which gets invoked after the main function completes its execution.
 
They are commonly used to handle asynchronous operations in JavaScript.

Callbacks are commonly used in programming to handle asynchronous tasks, such as fetching data from a server, reading files, or handling user interactions.



================================================================================

how handle asynchronous operations 

Handling asynchronous operations in programming involves
managing tasks that may take variable amounts of time to complete without blocking the execution of other code.

Asynchronous operations can be handled using various techniques, including callbacks, Promises, async/await, and event listeners




====================================================================================

https://www.wisdomgeek.com/development/web-development/javascript/javascript-promises-combinators-race-all-allsettled-any/

### Promises in JavaScript

- Promise is an object that representing the eventual completion or failure of an asynchronous operation and its resulting value. 

Promises provide a more effective way to handle asynchronous code, avoiding callback hell and making the code easier to read and maintain.


- promise has four States:

  1. Fulfilled: Action related to the promise succeeded.
  2. Rejected: Action related to the promise failed.
  3. Pending: Neither fulfilled nor rejected yet; the promise is still pending.
  4. Settled: The promise has been either fulfilled or rejected.

### Promise Methods

- then(): 
  - Invoked when a promise is resolved and a result is received.
  - Allows chaining multiple asynchronous operations.
- catch(): 
  - Invoked when a promise is either rejected or some error has occurred during execution.
  - Provides better error handling than callbacks and events.

### Differences between Promise.all(), Promise.allSettled(), Promise.any(), and Promise.race()

#### Promise.all()
   - Executes multiple promises in parallel and waits for all of them to resolve.
   - Rejects as soon as any one of the input promises rejects.
    - Resolves when all input promises have resolved.

   - Returns a single promise that resolves to an array of the results of the input promises.
   [ 'Wisdom', 'Geek', 'Wisdom' ]


#### Promise.allSettled()
   - Executes multiple promises in parallel and waits for all of them to settle, meaning each promise either resolves or rejects.

   - Resolves when all input promises have settled (either resolved or rejected).

  - Returns a single promise that resolves to an array of objects describing the outcome of each promise (each object has a status of either "fulfilled" or "rejected" and the corresponding value or reason).

Outputs:
[
  { status: 'fulfilled', value:  'Wisdom' },
  { status: 'rejected',  reason: 'Geek' },
]

#### Promise.any()

1. Purpose: 
   - Executes multiple promises in parallel and waits for any one of them to resolve.
   - Resolves as soon as any one of the input promises resolves.
   - Rejects if all input promises reject.

#### Promise.race()
   - Executes multiple promises in parallel and waits for the first one to settle (either resolve or reject whether it was a success or failure.).
   - Returns a single promise that settles with the result (or rejection reason) of the first settled promise.



- Outcome: A promise will produce a single value sometime in the future. If the promise is successful, it will produce a resolved value. If something goes wrong, it will produce a reason for the failure.




========================================================================

### 1. **Introduction to Promises**
Start by briefly explaining what a promise is in JavaScript:

A promise in JavaScript is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises are used to handle asynchronous operations more effectively than traditional callbacks."

### 2. What is Promise Chaining?**
Define promise chaining:

"Promise chaining is a technique in JavaScript that allows us to execute multiple asynchronous operations in sequence. Each operation returns a promise, and the result of one operation is passed to the next. This ensures that each asynchronous task completes before the next one begins, providing a clean and readable flow of operations."

### 3. **Why Use Promise Chaining?**
Explain the benefits:

"Promise chaining helps us avoid callback hell, making the code more readable and maintainable. It also allows for better error handling, as errors can be caught in a single `.catch()` block at the end of the chain."

### 4. **How Does Promise Chaining Work?**
Walk through a simple example:

"Let me give you a quick example:

```javascript
function fetchData() {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(10); // Simulate fetching data
        }, 1000);
    });
}

function processData(data) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(data * 2); // Simulate processing data
        }, 1000);
    });
}

function saveData(data) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve('Data saved: ' + data); // Simulate saving data
        }, 1000);
    });
}

fetchData()
    .then(data => processData(data)) // Pass the fetched data to processData
    .then(processedData => saveData(processedData)) // Pass the processed data to saveData
    .then(finalMessage => console.log(finalMessage)) // Log the final success message
    .catch(error => console.error('An error occurred:', error)); // Handle any errors
```

"In this example, `fetchData`, `processData`, and `saveData` are three asynchronous operations. Each of these operations returns a promise, and they are chained together using `.then()`. If any of these operations fail, the error will be caught by the `.catch()` at the end."

### 5. **Error Handling in Promise Chaining**
Discuss how errors are handled:

"One of the key advantages of promise chaining is centralized error handling. If any promise in the chain fails, the `.catch()` method will handle the error, preventing the need to handle errors at each individual step."

### 6. **Common Pitfalls and Best Practices**
Mention any pitfalls and best practices:

"While promise chaining is powerful, it's important to ensure that each promise in the chain is returning a new promise. Otherwise, the chain can break, leading to unexpected behavior. Additionally, using arrow functions helps to keep the syntax concise."

### 7. **Conclusion**
Wrap it up by reiterating the importance of promise chaining:

"Promise chaining is an essential technique in modern JavaScript development. It allows for clear, sequential execution of asynchronous tasks, improves readability, and simplifies error handling."

By explaining promise chaining in this way, you'll demonstrate a strong understanding of the concept and its practical applications in real-world scenarios.


-Promise are thr ideal choice for handling asynchronous operation in simplest manner
-they can handle multiple asynchronous operation easily and provide better error handling then Callback and event
#promise has four strategist
1]fulfilled: Action related to the promise succeeded
2] Rejected : Action related to the promise failed
3] pending- Neither fulfilled nor rejected yet means promise still pending.
4]settle- The Promise has been either fulfilled or rejected.

A].then():
-then() function is invoked when a promise is resolved and a result is received.

B].catch()
catch() function is invoked when a promise is either rejected or some error has occured in execution.

Applications
Promises are used for asynchronous handling of events.
Promises are used to handle asynchronous http requests.





A promise is an object which is used to perform asynchronous operations.

A promise gets settled(either resolved or rejected) in future.

If promise gets resolved then it calls the callback passed to then() function.

If promise gets rejected then it called the callback passed to catch() function.
then chaining

Writing multiple thens one after another for a promise is called then chaining

A then() returns a promise



===================================================================

### Why Use Promises Instead of Callbacks?

1. **Readability**: Avoids "callback hell" with cleaner code.
2. **Error Handling**: Centralized error handling with `.catch()`.
3. **Control**: Maintains control over asynchronous flow.
4. **Composability**: Easily run and manage multiple async operations.

Promises can be composed using methods like Promise.all, Promise.race, Promise.allSettled, and Promise.any. This allows for running multiple asynchronous operations in parallel and handling their results collectively.

5. **Standardization**: Native support in modern JavaScript (ES6).

Promises are a part of the ES6 (ECMAScript 2015) standard, meaning they are natively supported in modern JavaScript engines and have a consistent behavior across different environments.


//===========================asynch await =========================


-The async await is used to pause the execution of a function until a promise gets settled


-async keyword Put the before a function , tells the function to return a Promise
-await keyword is used within an async function to pause its execution until a Promise is settled.
- It waits for the Promise to resolve (either fulfilled or rejected) and then returns its result.
-await should only be used inside the async function.




//===========================asynch await =========================
async await

-The async await is used to pause the execution of a function until a promise gets settled

A] - Async Keyword:

-async keyword Put the before a function , tells the function to return a Promise
- This allows the function to use the "await" keyword internally to handle asynchronous operations.


B]- Await Keyword:


- "await" keyword is used within an async function to pause its execution until a Promise is settled.
- It waits for the Promise to resolve (either fulfilled or rejected) and then returns its result.
- Note: The "await" keyword can only be used inside async functions, otherwise, it would result in a SyntaxError.



-await should only be used inside the async function.

-The await keyword simply makes JavaScript wait until that Promise settles and then returns its result
-await keyword only works inside async functions, otherwise you would get a SyntaxError.




================================================================================


**Promises** and **async/await** are both tools in JavaScript for handling asynchronous operations, but they differ in syntax and usage:

### Promises

- **Definition**: An object representing the eventual completion or failure of an asynchronous operation and its resulting value.
- **Syntax**: Uses `.then()` and `.catch()` methods to handle resolved and rejected states.
- **Chaining**: Promises can be chained for sequential asynchronous operations.
- **Error Handling**: Errors are caught using `.catch()` or within a `.then()` callback with a second argument.
- **Example**:
  ```javascript
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve('Done!'), 1000);
  });

  promise
    .then(result => console.log(result)) // Logs 'Done!' after 1 second
    .catch(error => console.error(error));
  ```

### Async/Await

- **Definition**: Syntactic sugar built on top of Promises, providing a more readable and straightforward way to handle asynchronous code.
- **Syntax**: Uses `async` functions and the `await` keyword to handle asynchronous operations in a synchronous-like manner.
- **Chaining**: Async functions implicitly return a Promise and can use `await` for asynchronous operations.
- **Error Handling**: Errors are handled using `try/catch` blocks.
- **Example**:
  ```javascript
  async function fetchData() {
    try {
      const result = await new Promise((resolve, reject) => {
        setTimeout(() => resolve('Done!'), 1000);
      });
      console.log(result); // Logs 'Done!' after 1 second
    } catch (error) {
      console.error(error);
    }
  }

  fetchData();
  ```

### Key Differences

- **Syntax and Readability**: `async/await` provides a cleaner and more readable syntax compared to chaining `.then()` and `.catch()` with Promises.
- **Error Handling**: `async/await` uses `try/catch`, which many find more intuitive than handling errors with `.catch()`.
- **Control Flow**: `async/await` allows for more synchronous-like control flow in asynchronous operations, making complex sequences easier to manage.

In summary, **Promises** are suited for straightforward asynchronous tasks and integrating with existing codebases, while **async/await** simplifies code readability and error handling, making it ideal for more complex or sequential asynchronous operations.




//===========================global object =========================


Q1. what is global object in javascript?
-A global object is an object that always exists in the global scope
-In a web browser, the global object is the window object
-The global object can be accessed using the "this" operator in the global scope
-The global object in JavaScript is an always defined object that provides
variables and functions, and is available anywhere.



window is a global object of javascript it is used to load / display a web page
content in the web browser.

The window object represents a tab of a web browser, it includes navigation model, histoy,
location, document, etc.

document represents a web page in the web browser.

document object is a part of window object.

Using document object you can dynamically update the content on the viewport.


=========================================Set====================


Set:-
Set is like an array but it stores only unique elements.

An array is used to store multiple elements of any type, an array can store duplicate
elements.

// Creating a set
1. Creating empty set.
const s1 = new Set();

// add(value) - adds an element and returns the set after adding the element

const mySet =new Set([1,2,4,,5,6,6,,33,2,4,5,6,6,4,4,4,1,1,11,"A","a"])
console.log(mySet)

mySet.add({
    name:"Abc"
});
mySet.add({second:'This is second value'});
mySet.add('third','This is third value')
mySet.add('APlle')
mySet.add("apple")
console.log(mySet)
mySet.delete(1)
for(let val of mySet){
    console.log("val --",val)
}
// mySet.clear()




console.log(mySet)



//============================map ===============================


Map:- 
A Map is a built-in JavaScript object that store key value pairs with unique keys.
where the keys can be of any type, including objects, functions, and primitives.

keys in a JavaScript Map are unique. 
If you set a key that already exists in the Map, 
the value associated with that key is updated, not duplicated.


```javascript

const map = new Map();


// Add key-value pairs
map.set('name', 'Alice');
map.set('age', 25);

// Attempt to add a duplicate key
map.set('name', 'Bob'); // Updates the value for the 'name' key

console.log(map.get('name')); // "Bob"
console.log(map.size); // 2 (not 3, as keys are unique)


Creating // Create a new Map


### **Core Methods**

#### 1. **`set(key, value)`**  
Adds or updates a key-value pair in the `Map`.

const map = new Map();
map.set('name', 'Alice');
map.set(42, 'The answer');
console.log(map); // Map(2) { 'name' => 'Alice', 42 => 'The answer' }
```

#### 2. **`get(key)`**  
Retrieves the value associated with a given key.

```javascript
console.log(map.get('name')); // 'Alice'
console.log(map.get(42));     // 'The answer'
console.log(map.get('age'));  // undefined (key does not exist)
```

#### 3. **`has(key)`**  
Checks if a key exists in the `Map`.

```javascript
console.log(map.has('name')); // true
console.log(map.has('age'));  // false
```

#### 4. **`delete(key)`**  
Removes a key-value pair by the key.

```javascript
map.delete(42); 
console.log(map); // Map(1) { 'name' => 'Alice' }
```

#### 5. **`clear()`**  
Removes all key-value pairs from the `Map`.

```javascript
map.clear();
console.log(map); // Map(0) {}
```

#### 6. **`size` (Property)**  
Returns the number of key-value pairs in the `Map`.

```javascript
map.set('a', 1).set('b', 2).set('c', 3);
console.log(map.size); // 3
```

### **Iteration Methods**

#### 7. **`keys()`**  
Returns an iterator of all keys in the `Map`.

```javascript
for (const key of map.keys()) {
  console.log(key); // 'a', 'b', 'c'
}
```

#### 8. **`values()`**  
Returns an iterator of all values in the `Map`.

```javascript
for (const value of map.values()) {
  console.log(value); // 1, 2, 3
}
```

#### 9. **`entries()`**  
Returns an iterator of all key-value pairs in the `Map` as `[key, value]`.

```javascript
for (const [key, value] of map.entries()) {
  console.log(key, value); // 'a' 1, 'b' 2, 'c' 3
}
```

#### 10. **`forEach(callback)`**  
Executes a callback function for each key-value pair.

```javascript
map.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});
// Output:
// a: 1
// b: 2
// c: 3
```

### **Examples in Practice**

#### **Adding and Updating Data**
```javascript
const userRoles = new Map();
userRoles.set('Alice', 'Admin');
userRoles.set('Bob', 'Editor');
userRoles.set('Alice', 'Super Admin'); // Updates Alice's role

console.log(userRoles.get('Alice')); // 'Super Admin'
```

#### **Using Objects as Keys**
```javascript
const obj = { id: 1 };
const map = new Map();

map.set(obj, 'Object Value');
console.log(map.get(obj)); // 'Object Value'
```

#### **Iterating Over a Map**
```javascript
const items = new Map([
  ['apple', 10],
  ['banana', 5],
  ['cherry', 7],
]);

for (const [key, value] of items) {
  console.log(`${key}: ${value}`);
}
// Output:
// apple: 10
// banana: 5
// cherry: 7
```

#### **Counting Occurrences**
```javascript
const words = ['hello', 'world', 'hello', 'map'];
const wordCount = new Map();

words.forEach(word => {
  wordCount.set(word, (wordCount.get(word) || 0) + 1);
});

console.log(wordCount); // Map(3) { 'hello' => 2, 'world' => 1, 'map' => 1 }
```

Let me know if you need more examples or details!

========================= ===============================================

8. When to Use Map
Use a Map when:

You need non-string keys.
You need to maintain the order of entries.
You need efficient lookups and insertions.
You want built-in iteration over entries.

Use an object when:

You need simple key-value pairs with string keys.
You want inheritance or prototype-based features.
========================= ===============================================
### Set vs. Map
#Map
A Map is a built-in JavaScript object that stores key-value pairs.

A key value pair is called an entry
Keys in a Map must be unique, 
while values can be duplicated.

  - **Stores:** Key-value pairs.
  - **Uniqueness:** Keys must be unique; values can be duplicated.
  - **Methods:** `set(key, value)`, `get(key)`, `delete(key)`, `has(key)`, `size`.

It allows you to associate each key with a specific value and provides efficient methods for adding, retrieving, and deleting key-value pairs.

- **Set:**
 - **Definition:** A `Set` stores unique values, with no key-value pairs. It automatically removes duplicates.

  - **Key-Value:** No key-value pairs.
  - **Uniqueness:** Ensures all values are unique.
  - **Methods:** `add(value)`, `delete(value)`, `has(value)`, `size`.

 has(value): Check if a value exists in the Set.
forEach(callback): Iterates through the Set.
keys(), values(), entries(): Provides iterators for advanced use cases.
clear(): Clears the entire Set.

