
# ‚úÖ JavaScript Type Coercion

**Type coercion in JavaScript** means converting values from one type to another ‚Äî either automatically (implicit) or manually (explicit).

* **Implicit coercion** happens automatically (e.g., `'5' + 1` ‚Üí `'51'`).
* **Explicit coercion** is done deliberately using `Number()`, `String()`, `Boolean()`, etc.

> ‚ÑπÔ∏è To avoid bugs prefer **explicit conversion** and **strict equality (`===`)**.


## üîπ Types of Coercion

### 1. Implicit Coercion (Automatic)

JS converts types automatically when an operation requires it:

```js
console.log(1 + "2");   // "12"   (number ‚Üí string, concatenation)
console.log(1 - "2");   // -1     (string ‚Üí number, subtraction)
console.log("5" * "2"); // 10     (both strings ‚Üí number)
console.log(1 == "1");  // true   (loose equality coerces string ‚Üí number)
```

### 2. Explicit Coercion (Manual)

You convert types on purpose:

```js
console.log(Number("123"));   // 123
console.log(String(456));     // "456"
console.log(Boolean(0));      // false
console.log(Boolean("hi"));   // true
```

---

## ‚úÖ Implicit Coercion ‚Äî Operator behaviors & examples

### üî∏ `+` prefers **strings**

```js
'5' + 1         // "51"
false + '1'     // "false1"
"Hello " + 5    // "Hello 5"
```

### üî∏ `-`, `*`, `/` prefer **numbers**

```js
'5' - 1         // 4
true + 1        // 2       (true ‚Üí 1)
true + true     // 2
null + 1        // 1       (null ‚Üí 0)
undefined + 1   // NaN     (undefined ‚Üí NaN)
```

### üî∏ Comparison with `==` (loose equality)

```js
0 == false           // true
" " == 0             // true
null == 0            // false
undefined == null    // true
```

### üî∏ Boolean Context

```js
if ("") console.log("runs");       // doesn't run ("" is falsy)
if ("hello") console.log("runs");  // runs ("hello" is truthy)
```

---

## ‚úÖ Truthy & Falsy Values

* **Falsy values:**
  `false, 0, -0, 0n, "", null, undefined, NaN`

* **Truthy values:**
  Everything else (for example: `"0"`, `"false"`, `[]`, `{}`, `function(){}`).

---

## ‚úÖ Operator Preferences Summary

| Operator      | Coercion Preference |
| ------------- | ------------------- |
| `+`           | **Strings**         |
| `-`, `*`, `/` | **Numbers**         |

---

## ‚úÖ Explicit Type Coercion (manual conversions)

```js
Number('5')       // 5
String(10)        // "10"
Boolean(0)        // false
parseInt('42')    // 42
'' + 123          // "123"   // shortcut to string
```

---

## ‚úÖ Loose (`==`) vs Strict (`===`) equality ‚Äî Best Practice

```js
0 == false   // true   (coerced)
0 === false  // false  (no coercion)
```

‚úîÔ∏è Use **strict equality (`===`)** instead of `==`.
‚úîÔ∏è Use **explicit conversion** for clarity.

---

## üîÅ Quick Conversion Rules (Cheat Sheet)

* `+` with a string ‚Üí **string concatenation**.
* `-`, `*`, `/`, `%` ‚Üí operands coerced to **numbers**.
* `if(...)`, `while(...)`, `||`, `&&` ‚Üí values coerced to **boolean** (truthy/falsy).
* `==` ‚Üí performs type conversion (many special cases).
* `===` ‚Üí compares **without coercion**.




====================================================================================


```js
(null == undefined) // true  
(null === undefined) // false  
```

**null:**
Type: object
Represents an intentional "no value" set by the programmer.

**undefined:**
Type: undefined
Typically means a variable has been declared but not assigned a value yet.

**Why `==` considers them equal:**
Both `null` and `undefined` represent absence of a value or non-existence. Therefore, when using loose equality (`==`), JavaScript treats them as equal.

**Why `===` considers them different:**
In strict equality (`===`), JavaScript compares both value and type. Since `null` and `undefined` have different types (`object` and `undefined`), they are not equal.




====================================================================================---

why arrow functions ?

-Arrow functions do not have their own this context; instead, 
they inherit this from the parent scope at the time they are defined.

This is especially useful in:
Callbacks
Event handlers

 - Lexical this binding, avoiding this confusion.
- Concise syntax for defining functions.
- no need to return for single-expression functions.
- No binding of arguments object.
- Convenient for use in callbacks, especially with array methods.

Arrow functions streamline JavaScript code 
making it shorter, clearer, and more expressive, particularly in modern development practices
.





===================================== splice and slice ===============================================


## 1. `splice()`

* **Purpose:** Modify the original array by **adding**, **removing**, or **replacing** elements.
* **Mutates:** Yes ‚Äî it changes the original array.
* **Returns:** An array of the removed elements (if any).
* **Syntax:**

  ```js
  array.splice(startIndex, deleteCount, item1, item2, ...)
  ```
* **Parameters:**

  * `startIndex` ‚Äî position to start changing the array
  * `deleteCount` ‚Äî number of elements to remove from `startIndex`
  * `item1, item2, ...` ‚Äî elements to add starting at `startIndex`

### Example:

```js
const arr = [1, 2, 3, 4, 5];

// Remove 2 elements starting at index 1, and insert 'a', 'b'
const removed = arr.splice(1, 2, 'a', 'b');

console.log(arr);      // Output: [1, 'a', 'b', 4, 5]
console.log(removed);  // Output: [2, 3]
```

---

## 2. `slice()`

* **Purpose:** Extract a portion of the array and return it as a **new array**.
* **Mutates:** No ‚Äî original array stays unchanged.
* **Returns:** A new array with the selected elements.
* **Syntax:**

  ```js
  array.slice(startIndex, endIndex)
  ```
* **Parameters:**

  * `startIndex` ‚Äî start extracting from this index (inclusive)
  * `endIndex` ‚Äî stop extracting before this index (exclusive)

### Example:

```js
const arr = [1, 2, 3, 4, 5];

// Extract elements from index 1 up to (but not including) index 4
const newArr = arr.slice(1, 4);

console.log(arr);     // Output: [1, 2, 3, 4, 5]
console.log(newArr);  // Output: [2, 3, 4]
```
----------------------------------------------------------------------

In React.js, splice and slice are both methods used to manipulate arrays,
 but they have different purposes:

- splice()  :
  - Changes the contents of an array by removing or replacing existing elements and/or adding new elements.
  - Modifies the original array in place.
  - Syntax: array.splice(startIndex, deleteCount, item1, item2, ...)
  - startIndex: The index at which to start changing the array.
  - deleteCount: The number of elements to remove from the array (if set to 0, no elements are removed).
  - Example:
    
    const array = [1, 2, 3, 4, 5];
    array.splice(2, 1); // Removes 1 element starting from index 2
    // Result: array is now [1, 2, 4, 5]
  
    

- slice():
  - Returns a shallow copy of a portion of an array into a new array object selected from startIndex to endIndex (endIndex is not included).
  - Does not modify the original array.
  - Syntax: array.slice(startIndex, endIndex)
  - startIndex: The index at which to begin the extraction (inclusive).
  - endIndex: The index before which to end the extraction (exclusive).
  - Example:
    
    const array = [1, 2, 3, 4, 5];
    const newArray = array.slice(1, 4); // Returns a new array with elements from index 1 to index 3
    // Result: newArray is [2, 3, 4]
  

In short, splice changes the original array by adding, removing, or replacing elements, 
while slice returns a portion of the array as a new array without modifying the original.



====================================================================================



arr.splice(0) removes all elements from the array and returns them, leaving the array empty.
arr.splice(-n) removes the last n elements from the array and returns them.
arr.splice(-n, 0, item1, item2, ...) inserts elements before the last n elements without removing any


====================================================================================


* **`Object.freeze()`** ‚Üí cannot add, remove, or modify any properties of the object (completely immutable).
* **`Object.seal()`** ‚Üí you can update existing properties, but can‚Äôt add new or delete.
* **`Object.preventExtensions()`** ‚Üí you can update and delete properties, but can not add new properties.


By default in non-strict mode, freeze, seal, and preventExtensions do not throw errors ‚Äî they just silently fail.

But in strict mode ('use strict';), operations that break these rules will throw a TypeError.*.



====================================================================================


Object.freeze()
Object.seal()
Object.preventExtensions()



Object.freeze():=cannot add, remove, or modify any properties of the object compltede immutable
Object.seal():=you can update exastiting properties, but cant add new or delete
Object.preventExtensions():=you can update and delete properties ,but can not add new properties




Object.freeze(), Object.seal(), and Object.preventExtensions() are 
all methods in JavaScript used for controlling object mutability,
 but they have different levels of restriction.

1. Object.freeze(): 
   - This method completely freezes an object, making it immutable. 
   - Once an object is frozen, you cannot add, remove, or modify any properties of the object.
   - This means that the object becomes "read-only."
   - Example:
     
     const obj = { prop: 1 };
     Object.freeze(obj);
     obj.prop = 2; // This will fail silently or throw an error in strict mode
    

2. Object.seal():
- This method prevents new properties from being added to an object,
- You cannot add or remove properties from a sealed object.
- You can still modify existing properties' values.

   - Example:
     
     const obj = { prop: 1 };
     Object.seal(obj);
     obj.prop = 2; // This will change the value of 'prop'
     obj.newProp = 3; // This will fail silently or throw an error in strict mode
    

3. Object.preventExtensions():
   - you cannot addd  new properties  added to an object,
    but it allows existing properties to be modified or deleted.
   - Essentially, it makes an object non-extensible.

   - Example:
     
     const obj = { prop: 1 };
     Object.preventExtensions(obj);
     obj.prop = 2; // This will change the value of 'prop'
     obj.newProp = 3; // This will fail silently or throw an error in strict mode
     delete obj.prop; // This will delete the 'prop' property
    


In summary, 
 Object.freeze() makes an object completely immutable, 
Object.seal() makes it so you can modify existing properties but not add or remove them,
Object.preventExtensions() only prevents new properties from being added while allowing existing properties to be modified or removed.


====================================================================================
 
Explain Hoisting in javascript.

Hoisting is the default behaviour of javascript where the variable and function declarations to the top of their scope before code execution.



Hoisting is a **JavaScript behavior** where **variable and function declarations are moved to the top of their scope** (global or function) **before code execution**.

* **Variables declared with `var`** are **hoisted and initialized with `undefined`**.
* **`let` and `const`** are hoisted but **not initialized** (they are in a ‚Äútemporal dead zone‚Äù until their declaration).
* **Function declarations** are hoisted **with their entire definition**, so they can be called before they appear in the code.
* **Function expressions** (assigned to a variable) behave like variables: hoisted only as **undefined** if declared with `var`.

---

### **Examples**

```js
// var hoisting
console.log(a); // undefined
var a = 5;

// let/const hoisting
console.log(b); // ReferenceError
let b = 10;

// Function declaration hoisting
greet(); // Hello!
function greet() {
  console.log("Hello!");
}

// Function expression hoisting
sayHi(); // TypeError: sayHi is not a function
var sayHi = function() {
  console.log("Hi!");
};
```

---

‚úÖ **Key points:**

* Hoisting moves **declarations**, not **initializations**.
* `var` ‚Üí undefined, `let/const` ‚Üí temporal dead zone, function declarations ‚Üí fully hoisted.




Hoisting is the default behaviour of javascript where  the variable and function
declarations are moved on top during the compilation phase


====================================================================================
4. Difference between ‚Äú == ‚Äú and ‚Äú === ‚Äú operators.
Both are comparison operators.
The difference between both the operators is that ‚Äú==‚Äù is used to compare values whereas,
 ‚Äú === ‚Äú is used to compare both values and types.




====================================================================================



web workers




====================================================================================


## ‚úÖ Correct Explanation of Constructor Function Behavior in JavaScript

### üîπ1. Default Behavior of Constructor Functions

In JavaScript, when you use a **constructor function** with `new`, it automatically returns the new object instance unless you **explicitly return an object**.

```js
function Person(first, last) {
  this.firstName = first;
  this.lastName = last;
}

const person1 = new Person("John", "Doe");
console.log(person1); // ‚úÖ Person { firstName: 'John', lastName: 'Doe' }
```

---

### üîπ2. Returning a **Primitive** from a Constructor

If a constructor explicitly returns a **primitive value** (like a string, number, boolean, etc.), **that return value is ignored**, and the newly created object is returned instead.

```js
function Person(first, last) {
  this.firstName = first;
  this.lastName = last;

  return "Hello"; // üî¥ This return is ignored
}

const person2 = new Person("Jane", "Doe");
console.log(person2); // ‚úÖ Person { firstName: 'Jane', lastName: 'Doe' }
```

> ‚úîÔ∏è `this` is still returned, not the string `"Hello"`.

---

### üîπ3. Returning an **Object** from a Constructor

If a constructor explicitly returns an **object**, that object **overrides** the default `this`.

```js
function Person(first, last) {
  this.firstName = first;
  this.lastName = last;

  return { custom: "object" }; // ‚úÖ This replaces the created object
}

const person3 = new Person("Alice", "Smith");
console.log(person3); // ‚úÖ { custom: 'object' }
```

---

### üîπ4. Your Incorrect/Mismatched Example

You wrote:

```js
function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
  this.nationality = "English";

  // Returning a primitive value (string)
  return this.firstName;
}

const myFather = new Person("John", "Doe", 50, "blue");
console.log(myFather); 
// ‚ùå You wrote: Outputs Person {...}
// ‚úÖ Actually: Still returns the object, NOT the string
```

This example is labeled as **"returning a primitive"** but wrongly states that the object is replaced. It should clarify that **the primitive is ignored**, and the object is returned.

---

## ‚úÖ Summary

| Return Type       | What Happens                      |
| ----------------- | --------------------------------- |
| Nothing (default) | `this` (new instance) is returned |
| Primitive         | Ignored, `this` is still returned |
| Object            | Returned instead of `this`        |

---

If you're writing this for documentation or teaching, I‚Äôd recommend presenting **two clearly separated examples**, like above, with matching labels. Let me know if you‚Äôd like a polished markdown or HTML version.


========================================================================


The return this.firstName inside the constructor function will not work as intended 
because constructor functions implicitly return the newly created object unless you explicitly return an object.
 Returning a primitive value will override the object creation.

### returning an Object:
If you explicitly return an object from a constructor function, this returned object will replace the default instance that the constructor creates.

function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
  this.nationality = "English";

  // Returning a primitive value (string)
  return this.firstName;
}

const myFather = new Person("John", "Doe", 50, "blue");
console.log(myFather); // Outputs: Person { firstName: 'John', lastName: 'Doe', age: 50, eyeColor: 'blue', nationality: 'English' }


### Returning a Primitive Value:
If you explicitly return a primitive value (like a string, number, boolean, etc.), 
this value is ignored, and the newly created instance is returned instead.


function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
  this.nationality = "English";

  // Returning a new object
  return { custom: 'object' };
}

const myFather = new Person("John", "Doe", 50, "blue");
console.log(myFather); // Outputs: { custom: 'object' }
javascript
========================================================================


Why is a primitive ignored?

Primitives are not objects and cannot hold properties or behavior, whereas non-primitives (objects) can hold properties and methods.


========================================================================

In React.js development, the `window` object is often used for tasks related to application behavior and user interactions. Here are some `window` methods commonly used in React applications:

1. **`window.addEventListener()`**: Registers event listeners for various events (e.g., resize, scroll) to handle changes or interactions in the application.

2. **`window.removeEventListener()`**: Removes event listeners that were previously added, helping to clean up resources and avoid memory leaks.

3. **`window.scrollTo()`**: Used to programmatically scroll the window to a specific position, useful for smooth scrolling or navigation effects.

4. **`window.location.href`**: Gets or sets the URL of the current page, often used for programmatic navigation or redirecting.

5. **`window.localStorage`**: Provides access to local storage for storing and retrieving data on the client side.

6. **`window.sessionStorage`**: Provides access to session storage for storing data for the duration of the page session.

7. **`window.matchMedia()`**: Allows for querying and responding to media queries, useful for responsive design and handling different screen sizes.

8. **`window.requestAnimationFrame()`**: Schedules a function to be called before the next repaint, useful for implementing animations or optimizing performance.

9. **`window.history.pushState()`**: Updates the browser history stack without reloading the page, often used in single-page applications (SPAs) for managing navigation.

10. **`window.scrollY`**: Gets the number of pixels that the document is currently scrolled vertically, useful for tracking scroll position or implementing infinite scrolling.

These methods help manage application state, handle user interactions, and optimize performance in React.js applications.
