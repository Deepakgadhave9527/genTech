


------------------------------------------------------------------------------------------------



temporal dead 

The Temporal Dead Zone in JavaScript is the period during which variables declared with let, const  exist in their scope but are not yet initialized.

Accessing such variables in the TDZ results in a ReferenceError


console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 5;


------------------------------------------------------------------------------------------------
Implicit type coercion

Implicit type coercion in JavaScript is the automatic conversion of values from one type to another.

let result = '5' + 1; // '51' (string)
let result2 = '5' - 1; // 4 (number)


Avoiding Implicit Coercion

Use the strict equality operator (===) which does not perform type coercion.

Explicitly convert types using functions like Number(), String(), Boolean(), or methods like .toString().

Coercion

Coercion in programming refers to the automatic or implicit conversion of values from one data type to another. 
In JavaScript, t
his process is often automatic, especially when using the loose equality operator (==).


------------------------------------------------------------------------------------------------


(null == undefined) //true
(null === undefined) //false

null:
Type: object
Represents "no value" intentionally set by the programmer.

undefined:
Type: undefined
Typically means a variable is declared but has not been assigned any value yet.

Why == considers them equal:
Both null and undefined represent absence of a value or non-existence. Therefore, when using loose equality (==), JavaScript treats them as equal.

Why === considers them different:
In strict equality (===), JavaScript compares both value and type. Since null and undefined have different types (object and undefined), they are not equal.

---------------------------------------------------------------------------------------------------

why arrow functions ?

- Lexical this binding, avoiding this confusion.
-Arrow functions do not have their own this context; instead, 
they inherit this from the parent scope at the time they are defined. 

- Concise syntax for defining functions.
- no need to return for single-expression functions.
- No binding of arguments object.
- Convenient for use in callbacks, especially with array methods.

Arrow functions streamline JavaScript code, 
making it shorter, clearer, and more expressive, particularly in modern development practices
.
------------------------------------------------------------------------------------------------
StrictMode

-StrictMode is a tool for highlighting potential problems in an application.
-It helps identify unsafe lifecycles, deprecated APIs, and other potential problems.

- Unsafe lifecycle methods
- Legacy string refs
- Unexpected side effects
- Potential memory leaks
- Deprecated or obsolete APIs

-React introduces additional checks and warnings for potential issues during development.
-It's not for production use

-Like Fragment, StrictMode does not render any visible UI. 




------------------------------------------------------------------------------------------------


Internationalization vs Localization

1. Internationalization (i18n):- 
Making software for different languages, regions, and cultures by designing it flexibly. 
This includes separating text from code, using language-neutral formats for dates and numbers,
 and ensuring UI layouts can handle various text lengths and directions.

2. Localization (l10n): 

Customizing software for specific languages, regions, or cultures by translating text, 
formatting dates and numbers, and adapting the UI to match local expectations.
It involves creating language-specific versions of the software and tailoring the user experience accordingly.



------------------------------------------------------------------------------------------------
splice and slice

In React.js, splice and slice are both methods used to manipulate arrays,
 but they have different purposes:

- splice()  :
  - Changes the contents of an array by removing or replacing existing elements and/or adding new elements.
  - Modifies the original array in place.
  - Syntax: array.splice(startIndex, deleteCount, item1, item2, ...)
  - startIndex: The index at which to start changing the array.
  - deleteCount: The number of elements to remove from the array (if set to 0, no elements are removed).
  - Example:
    
    const array = [1, 2, 3, 4, 5];
    array.splice(2, 1); // Removes 1 element starting from index 2
    // Result: array is now [1, 2, 4, 5]
  
    

- slice():
  - Returns a shallow copy of a portion of an array into a new array object selected from startIndex to endIndex (endIndex is not included).
  - Does not modify the original array.
  - Syntax: array.slice(startIndex, endIndex)
  - startIndex: The index at which to begin the extraction (inclusive).
  - endIndex: The index before which to end the extraction (exclusive).
  - Example:
    
    const array = [1, 2, 3, 4, 5];
    const newArray = array.slice(1, 4); // Returns a new array with elements from index 1 to index 3
    // Result: newArray is [2, 3, 4]
  

In short, splice changes the original array by adding, removing, or replacing elements, 
while slice returns a portion of the array as a new array without modifying the original.



------------------------------------------------------------------------------------------------

Object.freeze()
Object.seal()
Object.preventExtensions()

Object.freeze(), Object.seal(), and Object.preventExtensions() are 
all methods in JavaScript used for controlling object mutability,
 but they have different levels of restriction.

1. Object.freeze(): 
   - This method completely freezes an object, making it immutable. 
   - Once an object is frozen, you cannot add, remove, or modify any properties of the object.
   - This means that the object becomes "read-only."
   - Example:
     
     const obj = { prop: 1 };
     Object.freeze(obj);
     obj.prop = 2; // This will fail silently or throw an error in strict mode
    

2. Object.seal():
- This method prevents new properties from being added to an object,
- You cannot add or remove properties from a sealed object.
- You can still modify existing properties' values.

   - Example:
     
     const obj = { prop: 1 };
     Object.seal(obj);
     obj.prop = 2; // This will change the value of 'prop'
     obj.newProp = 3; // This will fail silently or throw an error in strict mode
    

3. Object.preventExtensions():
   - you cannot addd  new properties  added to an object,
    but it allows existing properties to be modified or deleted.
   - Essentially, it makes an object non-extensible.

   - Example:
     
     const obj = { prop: 1 };
     Object.preventExtensions(obj);
     obj.prop = 2; // This will change the value of 'prop'
     obj.newProp = 3; // This will fail silently or throw an error in strict mode
     delete obj.prop; // This will delete the 'prop' property
    

In summary, 
 Object.freeze() makes an object completely immutable, 
Object.seal() makes it so you can modify existing properties but not add or remove them,
Object.preventExtensions() only prevents new properties from being added while allowing existing properties to be modified or removed.


------------------------------------------------------------------------------------------------
 
Explain Hoisting in javascript.
Hoisting is the default behaviour of javascript where  the variable and function
declarations are moved on top during the compilation phase

clousure inner function can be access of outer function


------------------------------------------------------------------------------------------------
4. Difference between “ == “ and “ === “ operators.
Both are comparison operators.
The difference between both the operators is that “==” is used to compare values whereas,
 “ === “ is used to compare both values and types.


------------------------------------------------------------------------------------------------
accessibility


Web accessibility  is the design and creation of websites that can be used by everyone.
<!-- Accessibility support is necessary to allow assistive technology to interpret web pages. -->
Accessibility in ReactJS refers 
to the web applications built with React are usable by people with disabilities. 
<!-- This includes individuals who may have visual, auditory, motor, or cognitive impairments.  -->
React provides various tools and techniques to make applications more accessible, such as:
-
1. Semantic HTML:
-Using appropriate HTML elements to provide meaning and structure to the content.
 For example, using <button> instead of <div> for clickable elements.

2. ARIA attributes:
-Accessible Rich Internet Applications (ARIA) attributes can be added
 to HTML elements to provide additional information to assistive technologies. 
React supports adding ARIA attributes to components to enhance accessibility.

3. Keyboard navigation:
-Ensuring that all interactive elements can be accessed and operated using a keyboard alone,
 without relying on mouse or touch input.

4. Focus management: Managing focus to ensure that users can navigate through the application in a logical order, 
and that focus is not trapped within certain elements.

5. Screen reader support: Testing applications with screen readers to ensure that content is properly announced and navigable.

6. Providing alternative text for images: Adding descriptive alt text to images to ensure that users with visual impairments understand the content.

7. Handling dynamic content: Ensuring that dynamically generated content is accessible and properly announced by assistive technologies.





------------------------------------------------------------------------------------------------
What is assistive technology in websites?
Screen readers, voice recognition software, reading assistants, and switch devices that replace the need to use a keyboard or mouse are examples of assistive technologies.


------------------------------------------------------------------------------------------------
Interceptors

Interceptors are a powerful feature provided by libraries such as Axios or HTML5 Fetch api 
that allow you to intercept and manipulate HTTP requests or responses globally 
before they are handled by your application. 
In the context of React.js, interceptors can be used to perform tasks such as adding authentication headers, logging requests, modifying responses, or handling errors.




------------------------------------------------------------------------------------------------



web workers




------------------------------------------------------------------------------------------------

