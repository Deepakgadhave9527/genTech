
====================================================================================

### ‚úÖ Coercion

**Coercion** in programming refers to the **conversion of a value from one data type to another**.

In **JavaScript**, coercion can be:

* **Implicit (automatic)** ‚Äî performed by JavaScript during operations like comparisons or arithmetic.
* **Explicit (manual)** ‚Äî done using functions like `Number()`, `String()`, or `Boolean()`.

This process is especially common when using **loose equality (`==`)**, where JavaScript attempts to **coerce the operands to the same type** before comparing them.

---

### Example:

```js
'5' == 5        // true ‚Üí '5' is coerced to number 5
```



====================================================================================

# ‚úÖ JavaScript Type Coercion 

**Type coercion in JavaScript** means converting values from one type to another ‚Äî automatically (implicit) or manually (explicit).

* **Implicit coercion** happens automatically (e.g., `'5' + 1` becomes `'51'`).
* **Explicit coercion** is done manually using functions like `Number()`, `String()`, or `Boolean()`.

> ‚ÑπÔ∏è To avoid bugs, prefer **strict equality (`===`)** and **explicit conversion**.



## ‚úÖ Implicit Type Coercion

JavaScript automatically converts types during operations.

### üî∏ `+` prefers **strings**

If one operand is a string ‚Üí string concatenation:

```js
'5' + 1           // "51"       ‚Üí number 1 is coerced to string
false + '1'       // "false1"   ‚Üí false becomes "false"
```

### üî∏ `-`, `*`, `/` prefer **numbers**

Operands are coerced to numbers:

```js
'5' - 1           // 4          ‚Üí '5' becomes number
true + 1          // 2          ‚Üí true becomes 1
true + true       // 2          ‚Üí both true ‚Üí 1
null + 1          // 1          ‚Üí null becomes 0
undefined + 1     // NaN        ‚Üí undefined becomes NaN
```

## ‚öñÔ∏è Loose Equality (`==`)

Examples of JavaScript‚Äôs loose equality behavior:

```js
null == 0              // false
undefined == null      // true
```



## ‚úÖ Operator Preferences Summary

| Operator      | Coercion Preference |
| ------------- | ------------------- |
| `+`           | **Strings**         |
| `-`, `*`, `/` | **Numbers**         |

---

------------------------------------------------------------------------------------------------

## ‚úÖ Explicit Type Coercion

Use built-in functions to manually convert values:

```js
Number('5')       // 5
String(10)        // "10"
Boolean(0)        // false
parseInt('42')    // 42
'' + 123          // "123"   ‚Üí also explicit
```



Use the strict equality operator (===) which does not perform type coercion.





====================================================================================


```js
(null == undefined) // true  
(null === undefined) // false  
```

**null:**
Type: object
Represents an intentional "no value" set by the programmer.

**undefined:**
Type: undefined
Typically means a variable has been declared but not assigned a value yet.

**Why `==` considers them equal:**
Both `null` and `undefined` represent absence of a value or non-existence. Therefore, when using loose equality (`==`), JavaScript treats them as equal.

**Why `===` considers them different:**
In strict equality (`===`), JavaScript compares both value and type. Since `null` and `undefined` have different types (`object` and `undefined`), they are not equal.




====================================================================================---

why arrow functions ?

-Arrow functions do not have their own this context; instead, 
they inherit this from the parent scope at the time they are defined. 
This is especially useful in:

Callbacks

Event handlers

 - Lexical this binding, avoiding this confusion.
- Concise syntax for defining functions.
- no need to return for single-expression functions.
- No binding of arguments object.
- Convenient for use in callbacks, especially with array methods.

Arrow functions streamline JavaScript code, 
making it shorter, clearer, and more expressive, particularly in modern development practices
.





===================================== splice and slice ===============================================


## 1. `splice()`

* **Purpose:** Modify the original array by **adding**, **removing**, or **replacing** elements.
* **Mutates:** Yes ‚Äî it changes the original array.
* **Returns:** An array of the removed elements (if any).
* **Syntax:**

  ```js
  array.splice(startIndex, deleteCount, item1, item2, ...)
  ```
* **Parameters:**

  * `startIndex` ‚Äî position to start changing the array
  * `deleteCount` ‚Äî number of elements to remove from `startIndex`
  * `item1, item2, ...` ‚Äî elements to add starting at `startIndex`

### Example:

```js
const arr = [1, 2, 3, 4, 5];

// Remove 2 elements starting at index 1, and insert 'a', 'b'
const removed = arr.splice(1, 2, 'a', 'b');

console.log(arr);      // Output: [1, 'a', 'b', 4, 5]
console.log(removed);  // Output: [2, 3]
```

---

## 2. `slice()`

* **Purpose:** Extract a portion of the array and return it as a **new array**.
* **Mutates:** No ‚Äî original array stays unchanged.
* **Returns:** A new array with the selected elements.
* **Syntax:**

  ```js
  array.slice(startIndex, endIndex)
  ```
* **Parameters:**

  * `startIndex` ‚Äî start extracting from this index (inclusive)
  * `endIndex` ‚Äî stop extracting before this index (exclusive)

### Example:

```js
const arr = [1, 2, 3, 4, 5];

// Extract elements from index 1 up to (but not including) index 4
const newArr = arr.slice(1, 4);

console.log(arr);     // Output: [1, 2, 3, 4, 5]
console.log(newArr);  // Output: [2, 3, 4]
```
----------------------------------------------------------------------

In React.js, splice and slice are both methods used to manipulate arrays,
 but they have different purposes:

- splice()  :
  - Changes the contents of an array by removing or replacing existing elements and/or adding new elements.
  - Modifies the original array in place.
  - Syntax: array.splice(startIndex, deleteCount, item1, item2, ...)
  - startIndex: The index at which to start changing the array.
  - deleteCount: The number of elements to remove from the array (if set to 0, no elements are removed).
  - Example:
    
    const array = [1, 2, 3, 4, 5];
    array.splice(2, 1); // Removes 1 element starting from index 2
    // Result: array is now [1, 2, 4, 5]
  
    

- sli vce():
  - Returns a shallow copy of a portion of an array into a new array object selected from startIndex to endIndex (endIndex is not included).
  - Does not modify the original array.
  - Syntax: array.slice(startIndex, endIndex)
  - startIndex: The index at which to begin the extraction (inclusive).
  - endIndex: The index before which to end the extraction (exclusive).
  - Example:
    
    const array = [1, 2, 3, 4, 5];
    const newArray = array.slice(1, 4); // Returns a new array with elements from index 1 to index 3
    // Result: newArray is [2, 3, 4]
  

In short, splice changes the original array by adding, removing, or replacing elements, 
while slice returns a portion of the array as a new array without modifying the original.



====================================================================================



arr.splice(0) removes all elements from the array and returns them, leaving the array empty.
arr.splice(-n) removes the last n elements from the array and returns them.
arr.splice(-n, 0, item1, item2, ...) inserts elements before the last n elements without removing any


====================================================================================


Object.freeze()
Object.seal()
Object.preventExtensions()

Object.freeze(), Object.seal(), and Object.preventExtensions() are 
all methods in JavaScript used for controlling object mutability,
 but they have different levels of restriction.

1. Object.freeze(): 
   - This method completely freezes an object, making it immutable. 
   - Once an object is frozen, you cannot add, remove, or modify any properties of the object.
   - This means that the object becomes "read-only."
   - Example:
     
     const obj = { prop: 1 };
     Object.freeze(obj);
     obj.prop = 2; // This will fail silently or throw an error in strict mode
    

2. Object.seal():
- This method prevents new properties from being added to an object,
- You cannot add or remove properties from a sealed object.
- You can still modify existing properties' values.

   - Example:
     
     const obj = { prop: 1 };
     Object.seal(obj);
     obj.prop = 2; // This will change the value of 'prop'
     obj.newProp = 3; // This will fail silently or throw an error in strict mode
    

3. Object.preventExtensions():
   - you cannot addd  new properties  added to an object,
    but it allows existing properties to be modified or deleted.
   - Essentially, it makes an object non-extensible.

   - Example:
     
     const obj = { prop: 1 };
     Object.preventExtensions(obj);
     obj.prop = 2; // This will change the value of 'prop'
     obj.newProp = 3; // This will fail silently or throw an error in strict mode
     delete obj.prop; // This will delete the 'prop' property
    

In summary, 
 Object.freeze() makes an object completely immutable, 
Object.seal() makes it so you can modify existing properties but not add or remove them,
Object.preventExtensions() only prevents new properties from being added while allowing existing properties to be modified or removed.


====================================================================================
 
Explain Hoisting in javascript.
Hoisting is the default behaviour of javascript where  the variable and function
declarations are moved on top during the compilation phase

clousure inner function can be access of outer function


====================================================================================
4. Difference between ‚Äú == ‚Äú and ‚Äú === ‚Äú operators.
Both are comparison operators.
The difference between both the operators is that ‚Äú==‚Äù is used to compare values whereas,
 ‚Äú === ‚Äú is used to compare both values and types.

====================================================================================



web workers




====================================================================================



========================================================================


The return this.firstName inside the constructor function will not work as intended 
because constructor functions implicitly return the newly created object unless you explicitly return an object.
 Returning a primitive value will override the object creation.

### returning an Object:
If you explicitly return an object from a constructor function, this returned object will replace the default instance that the constructor creates.

function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
  this.nationality = "English";

  // Returning a primitive value (string)
  return this.firstName;
}

const myFather = new Person("John", "Doe", 50, "blue");
console.log(myFather); // Outputs: Person { firstName: 'John', lastName: 'Doe', age: 50, eyeColor: 'blue', nationality: 'English' }


### Returning a Primitive Value:
If you explicitly return a primitive value (like a string, number, boolean, etc.), 
this value is ignored, and the newly created instance is returned instead.


function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
  this.nationality = "English";

  // Returning a new object
  return { custom: 'object' };
}

const myFather = new Person("John", "Doe", 50, "blue");
console.log(myFather); // Outputs: { custom: 'object' }
javascript

========================================================================

In React.js development, the `window` object is often used for tasks related to application behavior and user interactions. Here are some `window` methods commonly used in React applications:

1. **`window.addEventListener()`**: Registers event listeners for various events (e.g., resize, scroll) to handle changes or interactions in the application.

2. **`window.removeEventListener()`**: Removes event listeners that were previously added, helping to clean up resources and avoid memory leaks.

3. **`window.scrollTo()`**: Used to programmatically scroll the window to a specific position, useful for smooth scrolling or navigation effects.

4. **`window.location.href`**: Gets or sets the URL of the current page, often used for programmatic navigation or redirecting.

5. **`window.localStorage`**: Provides access to local storage for storing and retrieving data on the client side.

6. **`window.sessionStorage`**: Provides access to session storage for storing data for the duration of the page session.

7. **`window.matchMedia()`**: Allows for querying and responding to media queries, useful for responsive design and handling different screen sizes.

8. **`window.requestAnimationFrame()`**: Schedules a function to be called before the next repaint, useful for implementing animations or optimizing performance.

9. **`window.history.pushState()`**: Updates the browser history stack without reloading the page, often used in single-page applications (SPAs) for managing navigation.

10. **`window.scrollY`**: Gets the number of pixels that the document is currently scrolled vertically, useful for tracking scroll position or implementing infinite scrolling.

These methods help manage application state, handle user interactions, and optimize performance in React.js applications.
