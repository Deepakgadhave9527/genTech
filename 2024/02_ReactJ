

========================================================
Q21. What are fragments? Why are fragments better than container divs?

- react .fragment add group of multiple elements without adding an extra node in the Dom

- This is useful for returning multiple elements from a component without wrapping them in a div or another HTML element, which can lead to unnecessary markup and can disrupt CSS styling or layout.

- Fragments don't create extra DOM elements, it helps improve the rendering performance, especially in large applications.

React fragments use two syntaxes:
1. `<Fragment> ... </Fragment>`: Use this when you need to pass a key prop, typically in list rendering inside a `map()` method.

2. `<> ... </>`: Use this shorthand syntax when you do not need to pass a key prop.


Avoid Extra DOM Nodes
Improve Performance:


When you return multiple elements in a component's render method, they need to be wrapped in a parent element. Using Fragments prevents adding unnecessary extra DOM nodes (like <div> or <span>).
React fragments allow you to group multiple elements without adding an extra node to the DOM.


========================================================


‚úÖ **When to use `<Fragment>` (with `key`)**:  
- **Inside `.map()`** when rendering a list.  
- You **must** pass a `key` prop because React needs to **identify** each item during updates (add, delete, change).  
- Example:
  ```jsx
  {items.map(item => (
    <Fragment key={item.id}>
      <h2>{item.title}</h2>
      <p>{item.description}</p>
    </Fragment>
  ))}
  ```

‚úÖ **When to use `<>...</>` (shorthand Fragment)**:  
- **Outside** of `.map()`, when you are **just grouping** elements.  
- **No need** to pass a `key`.  
- Example:
  ```jsx
  function Page() {
    return (
      <>
        <h1>Title</h1>
        <p>Paragraph</p>
      </>
    );
  }
  ```

---

üîµ **Important Concept:**  
- In React, when rendering a list (like using `.map()`), each element **must** have a unique `key` prop.  
- The `key` helps React **identify** which items have changed, been added, or removed when updating the DOM.  
- This makes rendering **faster** and **more efficient**.

---

üîµ **Wrong Example** (‚ùå using `<>...</>` inside `.map()` without `key`):
```jsx
{items.map(item => (
  <>
    <h2>{item.title}</h2>
    <p>{item.description}</p>
  </>
))}
```
*(React will show a warning: "Each child in a list should have a unique 'key' prop.")*

---

üîµ **Correct Example** (‚úÖ using `<Fragment key={}>` inside `.map()`):
```jsx
{items.map(item => (
  <Fragment key={item.id}>
    <h2>{item.title}</h2>
    <p>{item.description}</p>
  </Fragment>
))}
```

  ========================================================

  Q22. What are error boundaries in React?

  - Error boundaries in React that catch JavaScript errors anywhere in their child component tree and log those errors.

- Error boundaries is helping to prevent the entire application from crashing due to a single error.
 -Error boundaries display a fallback UI instead of the component tree that crashed, 

- Use `getDerivedStateFromError()` is method to update the state to indicate an error has occurred.
        
- Error boundaries can only be created using **class base components** in React. 

- That's because React uses special lifecycle methods (like componentDidCatch) that only work in class components‚Äînot in function components.
- Function components don‚Äôt support those error-handling lifecycle methods directly, so React can‚Äôt use them as error boundaries.

- **Function base components** cannot directly act as error boundaries.

- You can wrap function components inside **class-based error boundaries** to catch errors during rendering.

- While function components cannot directly implement error boundaries, they can still utilize class-based error boundaries or external libraries to handle errors effectively.  

- Libraries like **`react-error-boundary`** provide hooks that enable error boundary behavior in function components.

- Function components can handle errors in **event handlers** or **asynchronous code** using `try-catch` blocks, but these won't catch rendering errors.



### **Errors Caught by Error Boundaries**
- **Render Phase**: Errors during component rendering.
- **Lifecycle Methods**: Errors in methods like componentDidMount, componentDidUpdate.
- **Constructors**: Errors in child component constructors.


### **Errors NOT Caught by Error Boundaries**
- **Event Handlers**: Use try-catch inside the handler.
- **Asynchronous Code**: Use try-catch or .catch() for Promises.
- **Server-Side Rendering (SSR)**: Handle SSR errors manually.
- **Errors in Error Boundary Itself**: Nest another error boundary if needed.

  -static getDerivedStateFromError() is a static method in a React class component that is
   invoked after an error has been thrown during rendering.

````javascript

  class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
          // Update state to indicate an error has occurred
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error("Error caught in Error Boundary:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
              // Fallback UI when an error occurs
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}


````
  ========================================================


  Q25. What is Lifting State Up in ReactJS?


- If we need to pass state/dtaa from a child component to a parent, we can use a concept called "lifting state up."

  If parent component needs state of child component then it can be passed to parent
  component using the concept called 'lifting state up'.

 In React, when you "lift state up," the **child component** doesn't directly send the state to the **parent**. Instead, the parent passes a **callback function** (as a prop) to the child, and the child invokes this function when it needs to "send" or update state in the parent.

Here's how it works:

1. **Parent defines state and a callback function**:
   - The **parent component** defines the state and a function to update that state.
   - This function is passed down to the child component via **props**.

2. **Child component calls the parent's function**:
   - The **child component** receives the parent's callback function as a prop.
   - When the child needs to "send" data to the parent (e.g., when an event occurs like a button click or form submission), it calls the parent's function and passes the relevant data as an argument.

### Example:

```jsx
// Parent Component
function ParentComponent() {
  const [childData, setChildData] = useState('');

  // Callback function to update the parent's state
  const handleDataFromChild = (data) => {
    setChildData(data);
  };

  return (
    <div>
      <h1>Parent Component</h1>
      <p>Data from Child: {childData}</p>
      {/* Pass the callback to the child */}
      <ChildComponent sendDataToParent={handleDataFromChild} />
    </div>
  );
}

// Child Component
function ChildComponent({ sendDataToParent }) {
  const [inputValue, setInputValue] = useState('');

  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  const sendData = () => {
    // Call the parent's function, passing the input data
    sendDataToParent(inputValue);
  };

  return (
    <div>
      <h2>Child Component</h2>
      <input type="text" value={inputValue} onChange={handleInputChange} />
      <button onClick={sendData}>Send Data to Parent</button>
    </div>
  );
}
```


========================================================


Q_18. What is the significance of keys in React?

- key is a unique identifier 

- Keys help React know which items have changed, been added, or removed, so it can update the UI with minimal changes and maximum performance.

During the reconciliation process (when React compares the previous and current UI), keys help React determine which elements have been added, removed, or changed.


<!-- 
- Keys help React identify which items have changed, been added, or removed in a list. 
-->

-During the reconciliation process (when React compares the previous and current UI), keys help React determine which elements are added, removed, or changed.

- During React's reconciliation process, keys help determine if an element is new or updated.
- React compares keys in two lists:
  - If the keys are the same, React reuses the component, avoiding re-rendering.
  - If the keys are different, React treats it as a new element and updates accordingly.
- This helps React update the UI efficiently.


-Keys should be given to the elements inside the array to give the elements a stable identity.

- key is assigned to react elements in a list to help which items have changed, been added, or removed, so it can update the UI with minimal changes and maximum performance.

- key is a unique identifier used by React to efficiently track and update elements in a list.


  ========================================================

Q8. What is PureComponent?

- PureComponent is a built-in class component in React that automatically performs a shallow comparison of props and state to determine whether the component should re-render.

<!-- - `PureComponent` is a built-in class component in React that automatically performs a shallow comparison of props and state to decide if the component needs to re-render. -->

- If the new props or state are the same as the previous values, the component will not re-render.

- Pure Components restricts the re-rendering and give the higher performance of the Component

- `PureComponent` is a type of React class component that automatically implements the `shouldComponentUpdate()` lifecycle method with a shallow comparison of props and state.

- It prevents unnecessary re-renders by only re-rendering the component when the values of props or state change.


- In function-based components, there is no direct equivalent to PureComponent. However, you can achieve similar performance optimization using React.memo. 
- React.memo is a higher-order component that works with function components to prevent unnecessary re-renders

React.memo: A higher-order component for function components that offers similar optimizations by preventing unnecessary re-renders through shallow comparison of props.



### Example
   
import React, { PureComponent } from 'react';

class MyComponent extends PureComponent {
  render() {
    // Render method implementation
  }
}

- Components which do not re-renders when the value of state and props has been updated with the same values.

- **Shallow Comparison**: PureComponent performs a shallow comparison of the current and next props or state. If nothing has changed (i.e., the new props or state are the same as the previous ones), it prevents a re-render.


- **Optimized Rendering**: Only re-renders if state or props change.
- **React Re-Render Triggers**:
  - `setState`: Called within the component.
  - `props Update`: Props values are updated.
  - `this.forceUpdate()`: Explicitly called to force a re-render.

### Summary
- Use Case: Ideal for optimizing performance when updates depend only on state or props.
- Comparison: Automatically implements shouldComponentUpdate with a shallow comparison.


PureComponent (Class-based): Automatically implements shouldComponentUpdate() with shallow comparison for performance optimization.

React.memo (Function-based): A higher-order component for memoizing function components, providing similar performance optimizations as PureComponent.


========================================================
Q11. What do you understand by refs in React?

- **"Refs are a feature provided by React to directly access and interact with DOM elements or React elements instances created during rendering."**

- Refs are attached to React elements using the special **ref attribute**. 

- Refs are used to manage focus, text selection, media playback, animations, and integrating with third-party libraries

**Class-Based Components**:
- createRef()` is primarily used in class base components to create ref .
- Use React.createRef() in the constructor.
- Access the ref using this.myRef.
- Attach the ref to an element in the render method.


```java

import React, { Component } from 'react';

class MyComponent extends Component {
  constructor(props) {
    super(props);
    // Create a ref
    this.myRef = React.createRef();
  }

  componentDidMount() {
    // Access the ref after the component mounts
    this.myRef.current.focus();
  }

  render() {
    return (
      <div>
        <input type="text" ref={this.myRef} />
      </div>
    );
  }
}

export default MyComponent;

```

**Function-Based Components**:
- Use the `useRef()` hook to create a ref in Functional Components
- Access the ref using myRef.current.
- Attach the ref to an element in the JSX.
- Use the useEffect hook for side effects.

-useRef() is used to create mutable object references that persist across renders without causing re-renders

 ```javascript
  const myRef = useRef(initialValue);
  ```

  ```javascript
  function MyComponent() {
      // Create a ref
      const myRef = useRef(null);

      useEffect(() => {
         // Access the ref after the component mounts
    myRef.current.focus();
          console.log(myRef.current); // Access DOM node
      }, []);

      return <div ref={myRef}>Hello, World!</div>;
  }
  ```

Class-based components use React.createRef() and this.myRef.
Function-based components use the useRef hook.


Using createRef() inside a functional component is not recommended because it creates a new ref object on every render,
which resets the ref value each time. 

In contrast, useRef() returns a persistent ref object that remains the same across all renders.


========================================================

Why is createRef() not recommended in functional components?


- **`useRef()`**: 
- It's a hook specifically designed for functional components in React. 
- It allows you to store a mutable reference to a DOM element or any value you want to persist across renders. 
- The ref object returned by `useRef()` does not cause re-renders when it changes, making it efficient for managing references or mutable values without triggering unnecessary updates.

- **`createRef()`**: 
- This is used primarily in class components and creates a fresh ref object on each render.

- When used inside a functional component, it will reset the ref value on every render, which defeats its purpose. - This can lead to issues with losing the previous state or ref value, and unnecessary re-renders may occur.

So, the primary difference is **persistence**:
- **`useRef()`**: Keeps the ref persistent across renders.
- **`createRef()`**: Does not persist across renders and re-creates the ref each time.

In functional components, always prefer `useRef()` for managing refs to avoid the issues associated with `createRef()`.


========================================================



Q12 what is dom ?

-DOM: DOM stands for ‚ÄòDocument Object Model‚Äô.
-It is a structured representation of the HTML elements
that are present in a webpage or web-app.
- JavaScript interacts with the DOM using the document object.  

- Includes element nodes, text nodes, and attribute nodes.  
- Enables adding, removing, or modifying elements and attributes dynamically.  
- Handles user interactions like clicks, key presses, and other events.  
- Provides methods for navigation (parentNode, childNodes) and modification (setAttribute, appendChild).  
- Allows real-time updates and interactivity in web pages.  



===============================================================================



**"Can you explain what the Virtual DOM is and how it works in React?"**

 - The Virtual DOM is a key concept in React that helps improve rendering performance of web pages updates.

 - Instead of updating the real DOM directly‚Äîwhich can be lead slow performance of web pages.
 
 -React uses the Virtual DOM to minimize costly updates.

- It is a lightweight, in-memory representation of the actual DOM. 

- When the components state or props change, React creates a new Virtual DOM tree and compares it with the previous one. This process is called *diffing*.

- React identifies the differences and updates only the changed parts in the real DOM.

This approach avoids unnecessary re-rendering of the entire UI, making updates much faster and more efficient.

===============================================================================

**Virtual DOM (VDOM)**:

The Virtual DOM is a concept that used improve the efficiency of web page updates.

-ReactJS does not update the real DOM directly but it updates the Virtual DOM
Virtual DOM is compared to Real DOM; virtual dom  updates only that part has changed 


 It is a lightweight, in-memory representation of the actual DOM. 
 
 When a components state changes, React creates a new Virtual DOM tree and compares it to the previous one. 
 The differences (or 'diffs') are computed, and only the changed parts are updated in the real DOM.


-Virtual DOM is about avoiding unnecessary update whole dom of rendering
This approach is time-efficient, leading to faster application performance.

===============================================================================

- When a component's state or props change, React  update the real DOM. 
Instead, it uses a process called reconciliation to determine the most efficient way to update the UI

- Reconciliation is the algorithm that React uses to update the UI. 

- Reconciliation is the process  React compares the current and updated Virtual DOM tree and determine the minimum number of changes required to update the actual DOM.

-This process makes UI updates efficient by minimizing expensive DOM operations and improving app performance.


React uses the Fiber architecture to manage the reconciliation process.

Fiber allows React to pause and resume work, break work into chunks, and improve responsiveness in large applications (especially in React 16+).

This enables concurrent rendering ‚Äî letting React prepare updates without blocking the main thread.


===============================================================================

**Reconciliation**:

When a component's state or props change, React doesn't immediately update the real DOM. 
Instead, it uses a process called reconciliation to determine the most efficient way to update the UI

-Reconciliation is the algorithm that React uses to update the UI. 

- Reconciliation is the process  React compares the current and updated Virtual DOM tree and determine the minimum number of changes required to update the actual DOM.

- React does this to optimize performance, because updating the real DOM is expensive.


-It works by comparing the current Virtual DOM tree to the updated one and 
 calculates the minimal changes required to synchronize the real DOM with the updated state.

**Optimization Techniques**:
1. **Tree Diffing**: React compares the current and updated Virtual DOM trees, identifying the minimal changes required.
2. **Batching**: React batches multiple changes into a single update, reducing the number of updates to both the Virtual DOM and the real DOM.


Reacts reconciliation

-Reconciliation is the algorithm that React uses to update the UI. 

- It works by comparing the current Virtual DOM tree to the updated one
  and making the minimum number of changes necessary to bring the real DOM in line with the updated state.


Reacts reconciliation is the process by which zReact updates the user interface efficiently when the component state or props change. Here‚Äôs a brief overview:

- **Virtual DOM**: React maintains a lightweight representation of the actual DOM called the Virtual DOM. When state or props change, React first updates the Virtual DOM.

- **Diffing Algorithm**: React uses a diffing algorithm to compare the new Virtual DOM with the previous version. It identifies changes by comparing nodes, minimizing the number of updates needed.

- **Re-rendering**: Once differences are identified, React determines the most efficient way to apply these changes to the actual DOM, updating only the parts that have changed.

- **Batch Updates**: React batches multiple updates together to improve performance and reduce the number of DOM manipulations.

In summary, React‚Äôs reconciliation process ensures that the UI updates efficiently and optimally by comparing and applying changes to the DOM based on the Virtual DOM.



"React‚Äôs reconciliation is an algorithm that compares the new Virtual DOM with the previous one, identifies what changed, and updates only those parts in the real DOM. This process makes UI updates efficient by minimizing expensive DOM operations and improving app performance. React also batches updates to reduce the number of DOM manipulations."



========================================================



Q14. What is the difference between Real DOM and Virtual DOM?
Below are the main differences between Real DOM and Virtual DOM,

Real DOM Virtual DOM

Updates are slow -------------------- Updates are fast
DOM manipulation is very expensive. -------------------- DOM manipulation is very easy
You can update HTML directly. -------------------- You Can‚Äôt directly update HTML
It causes too much of memory wastage -------------------- There is no memory wastage
Creates a new DOM if element updates -------------------- It updates the JSX if element update


========================================================


Q15 is the Shadow DOM the same as the Virtual DOM?

-No, they are different.

-The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in
web components.
-Virtual DOM optimizes UI updates
-used by JavaScript libraries like React to efficiently update the UI.

- This is a browser technology designed primarily for encapsulating and scoping variables, DOM, and CSS within web components.
- It allows you to create self-contained components with their own DOM structure and styling, isolated from the rest of the document.
-The virtual DOM is a concept implemented by libraries in JavaScript on top of browser APIs.


==============================================



Q23. What is lazy function in React?

Eager loading vs lazy loading

#1 Eager loading:-

-In case of eager loading, whole application gets initially(on first request )
-downloaded whether it is required or not.
-This will take more time to load the application initially

#2 Lazy loading:-
Lazy loading is a technique used to optimize the performance of an application by reducing its initial loading time by spliting the code
-In lazy loading the initial loading time of the application is reduced by spliting the code
-for spliting the code we can use using dynamic imports by React.lazy() method/function
-In lazy loading we can create  multiple bundle  instead of creating  single bundle
-Each bundle can be separately downloaded when required



#1 Static imports:-
import m from './module'


#2 Dynamic import :-
React.lazy();
const m = React.lazy(()=>import('./module'));


Your explanation is mostly correct but needs some refinement for clarity, grammar, and accuracy. Heres the corrected and polished version:


**Lazy Loading**:  

Lazy loading is a technique used to optimize the performance of an application by reducing its initial loading time by spliting the code

- Code splitting can be implemented using dynamic imports with the React.lazy() method.  
- Instead of creating a single large bundle, lazy loading allows the creation of multiple smaller bundles.  
- Each bundle is downloaded only when it is required, improving load times and reducing unused code in the initial load.




========================================================

Q. What are the different lifecycle methods in React?


Each React component has a lifecycle consisting of three main phases: Mounting, Updating, and Unmounting.

#  A ] Mounting:

This phase involves adding elements to the DOM. 

Mounting means putting elements into the DOM.

React has four built-in methods that gets called in mounting phase, in this order, when mounting a component:

1) constructor()
2) getDerivedStateFromProps()
3) render()
4) componentDidMount()

#1) constructor()

-We can set the initial state of the component inside this method.

-The constructor method is used to set the initial state and bind methods to the component.

2) get_Derived_State_From_Props()

- in this method React used to update a component's internal state based on changes in its props.
- It's invoked right before calling the render method.
- It returns an object to update the state or null if no update is needed.
- It takes two parameters: nextProps and prevState.


3) render()
The render() method is required, and
its the method that actually outputs the HTML to the DOM.


4) componentDidMount()
this method gets executed after mounting a component.
this method gets executed only once.
this method is used perform one time initialization operations like
fetching data from server, initializing a timer, etc.



# B] Updating:
-Updating is next phase in the React lifecycle
<!-- is when a component is updated. -->
-In updating phase, a mounted componented is modified.
-Updates in react are caused by changes in state or props.
-Update leads to re-rendering of the component.

React has five built-in methods that gets called, in this order, when a component is updated:

1)getDerivedStateFromProps()
2)shouldComponentUpdate()
3)render()
4)getSnapshotBeforeUpdate()
5)componentDidUpdate()



2)shouldComponentUpdate()
-this method controls the rerenderings of the component.
-this method returns boolean value.
-this method is return true when component rerender
-if return false then component will not rerender



4)getSnapshotBeforeUpdate(prevProps, prevState)
This method gets executed just after the render() method and before updating
the DOM.
This method is used hold some previous values like previous state and previous
props.
The value returned by this method will be availble as third parameter in
componentDidUpdate() method

5) componentDidUpdate(prevProps, prevState)
This method will get executed after updating the dom.
If you want to perform any operation after updating the application then write
that code here.


# C ] Unmounting:

componentWillUnmount. This method will get executed when a component is being removed from the DOM:
componentWillUnmount()
<!-- 
    1)componentWillUnmount()
  
    This method will get executed only once before removing the component from DOM.
    This method is used to perform resource releasing/cleaning operations like
    clear timer, close connections, etc. -->




===========================================================================

Q10. What are controlled and uncontrolled components in React?

## Controlled Component:
-In a controlled component, form data is handled by a React component.
-The input's value is controlled by React state.
-Updates to the input are done via the onChange event handler.
-It allows validation control.
-React handles the form‚Äôs data, making it easy to validate or modify.


## uncontrolled component:

- In an uncontrolled component, the form data is handled by the DOM itself.
- The input's value is managed by the DOM.
-It accepts its current value as a ref.
-It does not allow validation control.
- It‚Äôs simpler for scenarios where you don‚Äôt need to track state continuously.



-data is controlled by the DOM itself.
-It has limited control over the form elements and data.

-In Controlled Component current values accepts throug call back like onchange
-Data is controlled by the  react component.
-It has better control over the form elements and data.



**Q10: What are controlled and uncontrolled components in React?**

* **Controlled components** are form elements whose values are **controlled by React state**. You use `useState` (or `this.state` in class components) to store the input value, and update it using an `onChange` handler. This gives you full control over the form data, making it easier to implement validation, conditional input, and dynamic behavior.

  **Example:**

  ```jsx
  const [email, setEmail] = useState('');
  <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} />
  ```

* **Uncontrolled components** store their own state internally in the **DOM**, and React does not directly manage their values. Instead, you use a `ref` to access the input value when needed (like during form submission). This approach is simpler but offers less control.

  **Example:**

  ```jsx
  const emailRef = useRef();
  <input type="email" ref={emailRef} />
  ```

  Then you can access the value with `emailRef.current.value`.

---

**In short:**

* Use **controlled components** when you want React to manage the input value.
* Use **uncontrolled components** when you want the DOM to manage the value, and you only need it at specific times (like on submit).
With uncontrolled components, the value changes independently of React. So, you can‚Äôt run validation logic while typing, because React doesn't receive updates on every keystroke. You only access the value after the input is complete (like on submit), which is too late for interactive validation.




---------------------------------------------------------------
Q2. What is JSX and how JSX can help applications in React.js?



- JSX stands for **JavaScript XML** and is a syntax extension for JavaScript.  
- It allows writing **HTML-like syntax** directly in JavaScript.  
- JSX is **transpiled into JavaScript** using tools like **Babel**.  

- JSX integrates seamlessly with **React's Virtual DOM** for efficient updates.  
- It combines **structure (HTML)** and **logic (JavaScript)**, improving readability.  
- JSX simplifies creating **reusable, component-based UIs**.  
- **JavaScript expressions** can be embedded within JSX using {}.  
- It eliminates the need for methods like createElement() or appendChild().  
- **React.createElement()** is automatically used during JSX conversion.  
- Since React 17, **JSX no longer requires importing React** due to the new JSX transform.  


-JSX stands for JavaScript XML is a syntax extension for JavaScript that allows you to write HTML-like code within JavaScript.

- It is used in React to describe the structure of the user interface.

-JSX is a html like syntax.

-jSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement() or appendChild() methods.

- JSX converts HTML tags into react elements. by calling React.createElement(),
-this will be done by the babel.

- If you write JSX in a file then React package must be imported




========================================================
Q What is ReactDOM?

- Package: ReactDOM is a package that provides DOM-specific methods.
- Usage: Used at the top level of a web app to manage DOM elements efficiently.

 ReactDOM.render() Function
- Purpose: Renders a single React Component or multiple components wrapped in a parent component or a div element.
- Efficiency: Utilizes Reacts efficient methods for updating the DOM, such as changing only a subtree and using efficient diff algorithms.
- Return Value: Returns a reference to the component or null if a stateless component was rendered.





========================================================

Q4. What are the differences between a classs component and functional component?



### **Functional Components**  
- JavaScript functions that accept `props` as arguments and return React elements.  
-  Functional Components Created using **arrow functions** or **regular function syntax** to define the component.  

- Functionbase Components manage state using **hooks** like `useState`, `useReducer`, and more advanced hooks like `useContext`.  
- Lifecycle methods are handled via **hooks** like `useEffect`, allowing you to replicate `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.  

- Refs are managed using the `useRef` hook, allowing access to DOM elements or component instances.

- Cannot implement error boundaries directly; must wrap them with a class component.

- JSX is returned directly from the function body without needing a `render()` method.  
-React lifecycle methods cannot be used in functional components.
Functional component is also called as a stateless component.

- Functional components with hooks are preferred, providing a modern approach to managing component behavior and state.  
- Generally better performance as there is less overhead compared to class components.  
- Functional components are more concise, making the code easier to read and maintain.  

---

### **Class Components**  
- Components created using ES6 **class syntax**, extending `React.Component` or `PureComponent` for optimizations.  
- State is managed using `this.state` and updated using the `setState()` method, allowing more complex state logic.  

- Class components have built-in lifecycle methods such as `componentDidMount`, `shouldComponentUpdate`, `componentWillUnmount`, and `componentDidUpdate`.  

- Refs are managed using `React.createRef()`, which provides direct access to DOM nodes or class component instances.  

- Requires a `render()` method to return JSX, ensuring that components always return UI when rendered.  

- Class components can implement **error boundaries** to catch JavaScript errors anywhere in their child component tree using `componentDidCatch`.  

- While functional components with hooks are now preferred, class components are still widely used in older React codebases and libraries. 

- Class components can implement **shouldComponentUpdate** or extend `PureComponent` to prevent unnecessary re-renders.  

React class component is called as a state-full component.




 -->========================================================

Q17. Differentiate between stateful and stateless components?


Functional Component or Stateless component

Functional component is like pure function in JavaScript.
Functional component is also called as a stateless component.
The functional component only receives props from parent component and return you JSX elements.
The functional component does n‚Äôt play with any lifecycle methods of React and doesn‚Äôt play with the component state...


Class component or state-full component

React class component is called as a state-full component.
Stateful component plays with all life cycle methods of React.
This component will modify state.

------

When would you use a stateless component
When you just need to present the props
When you do not need a state, or any internal variables
When creating element does not need to be interactive
When you want reusable code

When would you use a stateful component?

When building element that accepts user input or element that is interactive on page
When dependent on state for rendering, such as, fetching data before rendering
When dependent on any data that cannot be passed down as props







========================================================

Q5. What is the difference between state and props?



#### **State**
- Managed **within** the component and can be modified using `setState()` (class components) or `useState()` (functional components).
-State is mutable.

- Used for **internal component management**, such as handling form inputs or toggling visibility.
- **Triggers re-rendering** when updated to reflect changes in the UI.


#### **Props**
-Props are the data or functions passed from a parent component to a child component.
-Props are immutable within the child component.
- **Triggers re-rendering** in the child component when updated by the parent.
-Props are used to communicate between components.




When the parent component updates its state or data (which is passed down through props), the child component automatically re-renders to reflect the updated values received via props.

- Used to **share data** and behaviors between components.

Parent component modifies the data using useState or setState() (for class components).
Child components receive the modified data via props.
When the parent's state changes, it re-renders and passes the updated data to the child, causing the child to update automatically.

Mutable means that the data can change over time.
Immutable means that the data cannot be changed within the component that receives it.





State

-state is maintained data inside a component.

-In case of class component local state can be maintained using 'state' property
-update the state using the setState() method.

-In case of function component state can be maintained by using useState() hook.

-If a child component need the state of parent component then that state can be passed
using props.

-State changes can be asynchronous.
-State is mutable.
-State holds information about the components.
-State cannot make components reusable.
-The State is internal and controlled by the React Component itself.



<!-- -It is local or owned by that specific component.
-The component itself will
-State cannot be accessed by child components.
-Stateless components cannot have State.
-States can be used for rendering dynamic changes with the component. -->


Props

-props is object used to pass data from parent component to child component
-props are read-only in the child component that receives them.

-Props are immutable.
-Props are used to communicate between components.

-Props make components reusable.
-Props are external and controlled by whatever renders the component.


-Props allow you to pass data from one component to other components as an argument.
-Props can be accessed by the child component.

-Stateless component can have Props.

<!---
-callback functions can also be passed, which can be 
-executed inside the child to initiate an update.
-Props are read-only.
 -->
 
-->========================================================



Q16: What is prop drilling and how can you avoid it?


- In Prop drilling there is a need to pass data through props from a component to hierarchy component that is deeply nested.

### How to Avoid Prop Drilling:

1. **Context API**  
2. **State Management Libraries (e.g., Redux, Recoil)**  
3. **Custom Hooks**  





========================================================
q19. What are React components?


-Components are the building blocks of any React app and a typical React app will have many of these.

-A React component can be either stateful or stateless.
-Stateful components are of the class type,
-while stateless components are of the function type.



========================================================

 ### Higher Order Components (HOCs)

-In React, Higher Order Component is an advanced technique for reusing component logic.

An HOC is a function that accepts a component as its argument and returns a new component with some added functionality

**Purpose**: HOCs are used to abstract and reuse logic in a single place, which can then be applied to multiple components. 
They allow for code reusability, manipulation of props, and handling state in a consistent manner.


With help of HoC You can do many tasks
Code Reusability
Props manipulation
State manipulation



-According to the official website,
-Higher-Order Components are not part of the React API.
-but They are pattern that emerges from Reacts compositional nature.



========================================================
Q what is redux ?

- Redux is a predictable state container for JavaScript applications.
- Redux is a state management tool

-There is a central store that holds the entire state of the application.
-Each component can access the stored state without having to send down props from one component to another.

-There are three building parts: actions, store, and reducers.

1]Action
-Action is static information about the event that initiates a state change.
-Actions are payloads of information that send data from our application to our store

<!-- 
Action is static information about the event that initiates a state change.
When you update your state with Redux,
you always start with an action.
Actions are in the form of Javascript objects, containing a type and an optional payload.
Actions are sent using the store.dispatch() method.
Actions are created via an action creator. -->



2] Reducers
In Redux, a reducer is a pure function that takes an action and the previous state of the application and returns the
new state

The action describes what happened and it is the reducer's job to return the new state based on that action.

3]Store

- A Store is an object that holds the whole state tree of your application.
- There is only be a single store in a Redux app,
- Whenever a store is created in Redux, you need to specify the reducer.

getState() returns the current state of the store

dispatch() This dispatches an action. It is the only way to update the application state

subscribe() This method subscribes a change listener to the state

unsubscribe() It‚Äôs useful when you no longer want to call your listener method when the state changes

<!-- Whenever the store is updated, it will update the React components subscribed to it -->

npm i @reduxjs/toolkit
npm i react-redux

//slice

import { createSlice } from "@reduxjs/toolkit";

const createSliceName =createSlice({
name:"",
initaiState:[],
reducers:{
nameOfEvent :(state,action){
return {...state}
}
}
})


export default createSlice.reducer
export const selector =(state)=>state
export const {nameOfEveent} =createSliceName.actions

//store

import { configureStore } from "@reduxjs/toolkit";

const store =configureStore({
reducer:{
counter:nameOfSlice
}
})


//app.js
import {Provider} from "react-redux"
import store from "./store"

<Provider store={store}>
  <App />
</Provider>

store acccess karna or store ko actions dispatch
when need to pass the

================================================================================

Redux Overview:
- It  state management tool for JavaScript applications.
- Utilizes a central store to hold the entire application state.
- Components can access stored state without prop drilling.

Key Building Parts:
1. Actions:
   - Define events initiating state changes.
   - Represented as JavaScript objects with a type and optional payload.
   - Sent using store.dispatch() method.
   - Created via action creators, which are functions returning action objects.


// Example of an action creator
const incrementCounter = (amount) => {
  return {
    type: 'INCREMENT_COUNTER',
    payload: amount
  };
};

// Dispatching the action
store.dispatch(incrementCounter(5));

2. Reducers:
   - Pure functions taking current state and action to produce a new state.
   - Based on the reduce function in JavaScript.
   - Specify how application state changes in response to dispatched actions.


// Example of a reducer
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT_COUNTER':
      return state + action.payload;
    default:
      return state;
  }
};

3. Store:
   - Object holding the entire state tree of the application.
   - Responsible for storing, reading, and updating state.
   - Updates trigger re-renders in React components subscribed to it.


// Example of creating a Redux store
import { createStore } from 'redux';

const store = createStore(counterReducer);

Redux Workflow:
- Dispatch: Method triggering actions with type and payload to reducers.
- Subscribe: Method used to subscribe to state updates from the store (store.subscribe()).
- Provider: Component providing the store data to its wrapped components.
- Connect: Function facilitating communication with the provider.
- Middleware: Used to extend Redux with custom functionality, often for dispatching asynchronous functions.

Benefits of Redux (Additional Points):
- Predictable Data Flow:
  - Redux enforces a unidirectional data flow, making it easier to understand how data changes in the application over time.
- Developer Tools:
  - Redux comes with a set of developer tools like Redux DevTools, which allow developers to inspect the state and actions, track changes, and debug the application efficiently.

These additional points provide more insight into the benefits and usage of Redux in JavaScript applications, along with code examples to illustrate their implementation. Let me know if you need further explanation or assistance!


  ========================================================

  

================================================================================================================================================================


useContext vs Redux



**useContext:**

-useContext is a hook provided by React.
-useContext is relatively easy to understand and requires less code compared to Redux.

-useContext hook is used to create common data that can be accessed throughout the
component hierarchy without passing the props down manually to each level.

-When the value of the Context will changes, all components consuming that Context will re-render.

- useContext is suitable for simpler applications with basic state management needs.


-Changes to the state are made by updating the value of the Context directly.
-useContext allows direct mutation of the state within the Context.
-It is better suited for smaller to medium-sized applications or for managing simpler global state needs.
-It allows components to consume data from a Context and s
hare it across the component tree without having to pass props manually at every level.

**Redux:**

-Redux is a state management library, commonly used with React applications.
-It is used to manage the data and state of larger applications in a predictable and centralized manner.
-Changes to the state in Redux are made using pure functions called reducers, which take the current state and an action as arguments and return the new state.
-Redux only re-renders the components that are affected by the updated state, optimizing performance.
-Redux can handle complex state updates and asynchronous actions more efficiently than useContext.
- Redux is preferable for complex applications with intricate state management requirements.

-The state in Redux is read-only, and changes are made by dispatching actions, which are handled by reducers to produce a new state.
-Redux is perfect for larger applications with complex state management needs, offering a structured and predictable way to manage application state.
-It can be complex to understand, especially for beginners, due to its concepts like actions, reducers, middleware, and store setup.




### `useContext`

- Purpose: A React hook used to manage global state or pass data across components without prop drilling.
- Usage: Ideal for managing component-specific states or sharing global data in smaller applications.
- Suitability: Good for simpler applications with basic state management needs, where a lightweight solution is sufficient.
- Limitations: May not be ideal for complex applications with extensive state management needs.
- Asynchronous Handling: Manual; typically managed using `useEffect` or custom hooks, which can be less efficient for complex async operations.
- Middleware: Not applicable; `useContext` does not have built-in middleware support. Any middleware-like behavior needs to be custom-built.

### Redux

- Purpose: A state management library that provides a single global store for managing the entire application's state.
- Usage: Designed for managing shared state across multiple components in large applications.
- Functionality: Centralized store with actions and reducers to handle state updates, including complex state and asynchronous actions.
- Advantages: Improves predictability and testability of applications by managing all state updates through a single store.
- Suitability: Better suited for complex applications with multiple data sources and intricate state updates.
- Asynchronous Handling: Efficiently managed through middleware like Redux Thunk (for handling async actions within action creators) or Redux Saga (for managing complex async flows with generators).
- Middleware:
  - Redux Thunk: Allows you to write action creators that return a function instead of an action, facilitating async operations.
  - Redux Saga: Manages side effects using generator functions, offering more control over complex asynchronous flows and parallel actions.
  - Other Middleware: Libraries such as Redux Logger can be used for logging actions and state changes, aiding in debugging.


In summary, `useContext` is best for simpler state management and is limited in middleware and async handling, while Redux offers advanced features, including middleware for async operations and a centralized store, making it ideal for complex applications.

======
================================================================================





  
  ### React State vs. Redux State

  #### React State:
  - Scope: Local to a component; each component manages its own state.
  - Usage: Best for state specific to a single component or a small part of the component tree.
  - Initialization: Use useState hook in functional components or this.state in class components.
  - Updating State: Use setState method or function; updates are asynchronous and can be batched.
  - Complexity: Ideal for simple, component-specific state; less boilerplate and easier setup.
  
  #### Redux State:
  - Scope: Global, managed by a centralized store; shared across the entire application.
  - Usage: Suitable for state that needs to be shared across multiple components or large parts of the app.
  - Initialization: Set up in a Redux store using reducers and initial state values; typically use createStore.
  - Updating State: State updated through actions and reducers; updates can be managed asynchronously with middleware like Redux Thunk or Redux Saga.
  - Complexity: Involves more setup and boilerplate; provides a structured, predictable way to manage complex state interactions.
  
  ### Key Differences:
  - React State:
    - Local to components.
    - Simple and less setup.
    - Ideal for small, localized state.
  
  - Redux State:
    - Global and centralized.
    - More setup and boilerplate.
    - Ideal for complex, shared state management.
  
  ### Choosing Between Them:
  - React State: Suitable for small to medium-sized applications with localized state needs.
  - Redux State: Best for large applications with complex state requirements and the need for sharing state across many components.
 
  ========================================================
-If a child component need the state of parent component then that state can be passed
using props.

-If parent component needs state of child component then it can be passed to parent
component using the concept called 'lifting state up'.




================================================================================

Redux vs Redux Toolkit

### Redux:

- Core library for state management.
- Involves writing significant boilerplate.
- Requires manual handling of immutability.
- Asynchronous logic typically requires middleware.

### Redux Toolkit:

- Provides utility functions to simplify Redux usage.
- Reduces boilerplate significantly.
- Offers built-in immutability helpers.
- Built-in support for handling asynchronous logic.

- Seamless integration with Redux DevTools Extension.





  