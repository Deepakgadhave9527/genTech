
========================================================================
### Media Queries in CSS


- A media query is a CSS technique used to apply styles to a web page based on specific characteristics of the device or browser viewing the page.

- Media queries allow you to apply CSS rules conditionally based on factors like screen size, device orientation, resolution, and more.

- With media queries, we can create responsive designs that adjust the layout and styling of a webpage for different devices, screen sizes, resolutions, and orientations.

- Media queries ensure that websites are user-friendly and optimized across a wide range of devices, from mobile phones to large desktop monitors.

- The @media rule, introduced in CSS2, made it possible to define different style rules for different media types.

- They are essential for building adaptive, flexible, and accessible web pages. 


The `@media` rule is used in media queries to apply different styles for different media types/devices.

#### Examples:

- Extra small devices (phones, 600px and down):
@media only screen and (max-width: 600px) {...}

- Small devices (portrait tablets and large phones, 600px and up):
@media only screen and (min-width: 600px) {...}

- Medium devices (landscape tablets, 768px and up):
@media only screen and (min-width: 768px) {...}

- Large devices (laptops/desktops, 992px and up):
@media only screen and (min-width: 992px) {...}

- Extra large devices (large laptops and desktops, 1200px and up):
@media only screen and (min-width: 1200px) {...}


#### Breakpoints:

- Mobile (extra small device) xs: size <= 575.98px
- Tablet (small device) sm: size >= 576px && size <= 767.98px
- Laptop (medium device) md: size >= 768px && size <= 991.98px
- Desktop (large device) lg: size >= 991.98px && size <= 1199.98px
- Big screen (extra large device) xl: size >= 1200px

### Media Types:
Media types specify the target device or output medium. Some common media types include:

- all
- braille
- handheld
- print
- screen
- speech
- tty
- TV

### Logical Operators

AND (and) ‚Äì Combines multiple conditions.
OR (,) ‚Äì Applies if any condition is met.
NOT (not) ‚Äì Reverses the condition.


========================================================================
### What is <!DOCTYPE html>?

- `<!DOCTYPE html>` is a declaration that tells the browser which version of HTML the document is using.  
- It ensures the browser renders the page in **standards mode**.

-By using <!DOCTYPE html>, you indicate that the page follows HTML5 standards, which are the latest and most widely used version of HTML.

### What happens if you don‚Äôt include `<!DOCTYPE html>`?

- The browser switches to **Quirks Mode**.

This can cause CSS and layout issues, like:

- Box model behaving incorrectly  
- Inconsistent spacing and alignment  
- Fonts, margins, and widths rendering differently across browsers  
- Some modern CSS and JavaScript features may not work properly  
  ‚Äì Media queries and modern layout techniques (Flexbox/Grid) may not work properly  
  ‚Äì Some DOM methods or ES6+ features may not behave properly  


### What is Quirks Mode?

- **Quirks Mode** is a browser rendering mode used for backward compatibility with very old web pages.
- It is triggered when a web page lacks a proper `<!DOCTYPE>` declaration or has an incorrect one.

- To avoid **quirks mode**, always include `<!DOCTYPE html>` at the beginning of your HTML document.

========================================================================

- **Absolute units**:
  - Are fixed and do not change with the size of the viewport or parent element.
  - Useful when precise control over sizes is needed, such as in print styles or pixel-perfect designs.
  - Common absolute units include `px`, `pt`, `in`, `cm`, and `mm`.

- **Relative units**:
  - Adapt to the size of the parent element, viewport, or root element, making them more flexible for responsive designs.
  - Allow elements to scale based on screen size, font size, or other relative measurements.
  - Help maintain flexible layouts and enhance accessibility by scaling with text size or viewport dimensions.
  - Common relative units include `%`, `em`, `rem`, `vw`, `vh`, `vmin`, and `vmax`.

**Summary**:  
- **Absolute units** are fixed measurements that don't change relative to other elements, ideal for static, precise sizing.
- **Relative units** are dynamic and adapt based on other factors like the viewport or parent element size, enabling flexible and responsive design.

========================================================================


- **Absolute Units:** 
- Absolute length units are fixed and do not change relative to any other elements or the viewport.
- They are typically used when you need precise, static measurements.

Fixed measurements that don't change relative to other elements. 


### **Examples Absolute Units:**
- **`px` (pixels)**: Fixed unit, 1 pixel on the screen.
- **`pt` (points)**: 1 point = 1/72 inch, used in print.
- **`in` (inches)**: 1 inch = 2.54 cm, used for print.
- **`cm` (centimeters)**: Physical measurement in centimeters.
- **`mm` (millimeters)**: Physical measurement in millimeters. 

- **Relative Units:** 

Relative length units are based on other dimensions, such as the dimensions of the viewport, the font size, or the parent element. These units are useful for creating flexible and responsive layouts.

Measurements based on other dimensions or the viewport. 



### **Relative Units in CSS**

- **`%`**: Relative to the **parent element‚Äôs size** (width, height).
- **`em`**: Relative to the **font size of the current element**.
- **`rem`**: Relative to the **root element‚Äôs font size** (usually `<html>`).
- **`vw`**: Relative to the **viewport width** (1% of the viewport width).
- **`vh`**: Relative to the **viewport height** (1% of the viewport height).

- **`vmin`**: Relative to the **smaller dimension** of the viewport.
- **`vmax`**: Relative to the **larger dimension** of the viewport.
- **`ch`**: Relative to the **width of the ‚Äú0‚Äù character** in the font.
- **`ex`**: Relative to the **height of the lowercase ‚Äúx‚Äù** in the font.

These units help create **responsive** and **scalable** designs.

### **Relative Units in CSS**

- **`%` (Percentage)**:
  - Relative to the **parent element‚Äôs size**.
  - A percentage is calculated as a fraction of the parent‚Äôs dimensions (width, height, padding, etc.).
  - Example: `width: 50%` means 50% of the parent element's width.

- **`em` (Relative to the font size of the element)**:
  - Relative to the **current element's font size**.
  - If no font size is set on the element, it is inherited from the parent.
  - Example: If the parent has `font-size: 16px`, then `1em` = `16px`. 
  - `2em` would be `32px` if the parent font size is `16px`.
  - Used for scaling font sizes, margins, padding, etc.

- **`rem` (Relative to the root element's font size)**:
  - Relative to the **root element's font size** (typically `<html>`).
  - If the root element (`<html>`) has `font-size: 16px`, then `1rem` = `16px`. 
  - `2rem` would be `32px`.
  - Consistent across the page, unlike `em`, which is dependent on the parent element.

- **`vw` (Viewport Width)**:
  - Relative to the **viewport‚Äôs width** (the width of the visible area of the browser).
  - 1 `vw` = **1% of the viewport width**.
  - Example: `width: 50vw` means the element will take up 50% of the viewport's width.
  - Useful for responsive layouts, especially in terms of width.

- **`vh` (Viewport Height)**:
  - Relative to the **viewport‚Äôs height** (the height of the visible area of the browser).
  - 1 `vh` = **1% of the viewport height**.
  - Example: `height: 50vh` means the element will take up 50% of the viewport's height.
  - Often used for full-screen sections or hero areas.

- **`vmin` (Viewport Minimum)**:
  - Relative to the smaller of the **viewport‚Äôs width or height**.
  - 1 `vmin` = **1% of the smaller dimension** of the viewport.
  - Example: If the viewport width is 1200px and height is 800px, `1vmin` will be **8px**.
  - Useful when you want a size that adjusts proportionally to the smaller dimension.

- **`vmax` (Viewport Maximum)**:
  - Relative to the larger of the **viewport‚Äôs width or height**.
  - 1 `vmax` = **1% of the larger dimension** of the viewport.
  - Example: If the viewport width is 1200px and height is 800px, `1vmax` will be **12px**.
  - Used when you want a size that adapts to the larger viewport dimension.

- **`ch` (Character Width)**:
  - Relative to the width of the **‚Äú0‚Äù (zero)** character of the current font.
  - 1 `ch` = **the width of the "0" character** in the current font.
  - Example: `width: 20ch` means the element will be as wide as 20 characters of the current font.

- **`ex` (X-height)**:
  - Relative to the **height of the lowercase ‚Äúx‚Äù** in the current font.
  - The `ex` unit is dependent on the font's specific metrics.
  - Example: `font-size: 5ex` means the font will be 5 times the height of the lowercase "x" in the font.


### **When to Use Relative Units**

- **Responsiveness**: Use units like `vw`, `vh`, `%` for building layouts that adapt to screen sizes.
- **Scalability**: `em` and `rem` are great for scaling font sizes and elements proportionally.
- **Accessibility**: Relative units like `rem` make it easier for users to adjust font sizes based on their preferences.
- **Consistency**: `rem` provides a consistent, predictable scaling method for elements that is not dependent on parent styles.



========================================================================
### calc()

- `calc()` is a CSS function used to perform **calculations** to determine CSS property values.
- It allows combining different units (e.g., `%`, `px`, `em`) in a single expression.
- It is especially Useful for creating **responsive layouts** and **precise spacing**

- Works in most CSS properties like `width`, `height`, `margin`, `padding`, `font-size`, etc.
- Must have **spaces** around operators (`+`, `-`, `*`, `/`).
- Can mix units (e.g., `px` with `%`).


### **Example:**
```css
.container {
  width: calc(100% - 200px);
  padding: calc(1em + 10px);
}
```


### Why Use calc() in CSS?
- To combine different units (e.g., % and px) in one property.
- When a container needs to be a percentage of the parent but also needs to subtract some fixed space (like sidebars or padding).

========================================================================
### var()

In CSS, `var()` is used to reference **custom properties** (commonly called CSS variables). These are defined using the `--` syntax and can be reused throughout your stylesheet.

### üìå Basic Syntax

```css
:root {
  --primary-color: #0076ad;
  --font-size: 16px;
}

body {
  color: var(--primary-color);
  font-size: var(--font-size);
}
```

### üîç Breakdown:
- `:root` is a pseudo-class that targets the top-level element (`<html>`), so variables are globally available.
- `--primary-color` and `--font-size` are custom properties.
- `var(--primary-color)` retrieves the value defined earlier.


### üîπ Q1: Is `:root` only a pseudo-class?

Yes, `:root` **is a pseudo-class selector** in CSS.

- It targets the **top-level element** in the DOM (usually the `<html>` element).
- It‚Äôs just like using `html`, but has **higher specificity**, which is useful when overriding styles.

```css
:root {
  --main-color: blue;
}
```

So yes, `:root` is a **CSS pseudo-class** used primarily for defining global CSS variables.


### üîπ Q2: Are variables declared only globally?

Not necessarily ‚Äî CSS variables can be declared **anywhere**, not just globally.

- **Global Scope**: Use `:root` to define variables available everywhere.

```css
:root {
  --text-color: black;
}
```

- **Local Scope**: You can define them inside any selector, and they‚Äôll only work inside that scope.

```css
.card {
  --text-color: red;
  color: var(--text-color);
}
```

üîÑ So:  
- Variables are **not only global**.  
- Scope depends on **where you declare them**.


### üîπ Q3: Why use only `:root` to declare variables, not other ways?

You **don‚Äôt have to** use only `:root`, but we **prefer it** for **global reuse**:

- Declaring in `:root` makes them **available everywhere** in your stylesheet.
- It's a clean way to manage **global theming**, like colors, fonts, spacing, etc.

```css
/* Reusable theme settings */
:root {
  --font-family: 'Segoe UI', sans-serif;
  --border-radius: 4px;
}
```

But in some cases, declaring variables **locally** (in a `.class` or `#id`) is useful when you want **component-level control**.


- **Reusability:** Define a value once and use it throughout your stylesheet.
- **Maintainability:** Update a value in one place, and the change is reflected everywhere it's used.
- **Consistency:** Ensure consistent styling by using the same variables for similar properties.
- **Flexibility:** Easily adjust values for different themes or designs by changing variable values.
- **Scoped Variables:** Variables can be defined at different levels (global or local) for fine-grained control over styling.



================================ Semantic elements ====================================

**Semantic Elements in HTML**

Semantic elements are HTML tags that clearly describe their meaning to both the browser and developers.


### Benefits of Semantic Elements:

#### üîç **Clarity**
- Code becomes easier to read and understand.

#### üß† **Meaning**
- Tags describe *what* the content is ‚Äî not just *how* it looks.

#### ‚ôø **Accessibility**
- Helps screen readers and assistive tools navigate more effectively.

#### üîé **SEO**
- Search engines better understand the structure of your page.


### Cleaner, More Meaningful HTML Structure

#### üìà Why This Helps SEO:
- Search engines easily detect page structure using tags like `<header>`, `<nav>`, `<main>`, `<article>`, and `<footer>`.
- Headings like `<h1>` and `<h2>` help bots understand the content hierarchy.
- `<nav>` links are recognized as key site navigation ‚Äî crucial for effective crawling.

#### ‚ôø Why This Helps Accessibility:
- Screen readers can skip to `<nav>` or `<main>` directly using keyboard shortcuts.
- Tags like `<article>` signal independent, readable content ‚Äî improving organization.
- `<footer>` indicates the end of content, reducing confusion for assistive technologies.


### Common Semantic Elements:

```html
<article>
<aside>
<details>
<figcaption>
<figure>
<footer>
<header>
<main>
<mark>
<nav>
<section>
<summary>
<time>
```


===============================================================================
pseudo-classes vs Pseudo-Elements 


1.  ##Pseudo-classes (:) ##:
   - Primarily used to style elements under various states.
   When referring to state, this includes the condition or user interaction,

   - Common pseudo-classes include `:hover`, `:active`, `:focus`, and `:disabled`.
   - Denoted by a single colon (:).
   - States generally involve user interaction.

   <style>
  a:hover {
    color: red;
  }
</style>

<a href="#">Hover over me</a>


2.  ##Pseudo-Elements (::) ##:
   - Used to style specified parts of an element.
   - Denoted by a double colon (::).
   - Common pseudo-elements include
    `::before`, `::after`, `::first-letter`, and `::first-line`.

   - Can target the first letter or first line of text within an element, among other things.
   - Can be used to insert content before or after the element.

   <style>

    p::before {
      content: "Before "
    }

    p::after {
      content: " After";
      font-style: italic;
    }
  

</style>
  <p>This is a paragraph.</p>




================================================================================


# üìå CSS `position` Property 

The **`position` property** in CSS specifies how an element is positioned in the document, and how it interacts with the document‚Äôs normal flow.

The possible values are:
- `static` (default)
- `relative`
- `absolute`
- `fixed`
- `sticky`



### Static  
- The default position for all elements.
- Elements are positioned according to the normal document flow (block elements stack vertically, inline elements flow left to right).
- Not affected by the `top`, `right`, `bottom`, or `left` properties.
- It occupies space in the layout as normal  (Holds space in the layout).


### Relative  
- Positioned relative to its normal (static) position.
- its Holds its space in the layout ‚Äî other elements behave like it hasn‚Äôt moved.

-the measurement of positioning properties top, right, bottom, left starts from the element‚Äôs by default (static) position in the normal flow.
- You can move it using `top`, `right`, `bottom`, `left`.




### Absolute  
- Positioned relative to the nearest positioned ancestor (an ancestor with `position: relative`, `absolute`, `fixed`, or `sticky`).
- If no positioned ancestor exists, it‚Äôs positioned relative to the `<html>` (viewport‚Äôs initial containing block).
- Removed from the normal flow ‚Äî it does not hold space in the layout.
- Can be moved using `top`, `right`, `bottom`, `left`.
- Often overlaps other content.

Use case: Modals, dropdown menus, tooltips, floating buttons.




### Fixed  
- Positioned relative to the viewport.
- Does not hold space in the layout.
- Does not move when the page is scrolled ‚Äî it stays fixed in its position on the screen.
-Setting the location of an element on the screen or view port , we can use top, right, bottom, left position properties.
- Always relative to the viewport, never to any container.




-  ## Fixed ##: 
- Positioned relative to the viewport.
-  property in CSS will stay fixed in place even when the page is scrolled.
- It will remain in the same position, positioning an element relative to the browser window.
- Removed from the normal flow ‚Äî does not hold space in the layout.
- Can be positioned using top, right, bottom, left, specifying distances from the viewport's edges
- Measurement starts from body.
- the measurement does start from the viewport or body, not from any parent element.



**Use case:** Fixed navigation bars, sticky sidebars, floating action buttons.


### Sticky  
- Initially Sticky properties Behaves like `relative`.
- When it reaches a specified scroll threshold (e.g., `top: 0`), it switches to `fixed` positioning.

- Sticks within its nearest scrollable ancestor‚Äôs boundaries ‚Äî once those are exceeded, it stops being sticky.
-Does not remove space from the layout- **Holds space** in the layout.

-Setting the location of an element on the screen or view port , we can use top, right, bottom, left position properties.

- Measurement for position: sticky; starts from the nearest scrollable ancestor, not from the viewport or body.
  - it moves only within the viewport




### Key Points to Remember  
- **Removed from normal flow** ‚Üí element no longer affects the layout around it (`absolute`, `fixed`).
- **Holds space** ‚Üí layout space is still reserved (`static`, `relative`, `sticky`).
- **Scroll behavior matters** ‚Üí `fixed` never moves, `sticky` switches to `fixed` after a point.
- `absolute` and `fixed` overlap other content if not handled carefully.


static, relative, sticky  is hold space ‚úÖ  
absolute, fixed is not hold space ‚ùå  




================================================================================


### Block Elements:
- Start on a new row.
- Take up the full width .
- Width and height can be set.
- You can fully control their box model.


- Examples: `<div>`, `<p>`, `<li>`, etc.

1)    <address>
2)    <article>
3)    <aside>
4)    <blockquote>
5)    <canvas>
6)    <dd>
7)    <div>
8)    <dl>
9)    <dt>
10)    <fieldset>
11)    <figcaption>
12)    <figure>
13)    <footer>
14)    <form>
15)    <h1> - <h6>
16)    <header>
17)    <hr>
18)    <li>
19)    <main>
20)    <nav>
21)    <noscript>
22)    <ol>
23)    <p>
24)    <pre>
25)    <section>
26)    <table>
27)    <tfoot>
28)    <ul>
29)    <video>  

Let me know if you need further modifications!

 ### Inline Elements:
- Don't start on a new line)   
- Display on the same line if there is enough space available.
- Width and height cannot be set.
- Margins and padding apply horizontally.
- Examples: `<span>`, `<a>`, `<strong>`, `<img>`, `<input>`.


Here is a list of **15 inline elements** with just their names, numbered:

1. <a>
2. <b>
3. <br>
4. <cite>
5. <code>
6. <em>
7. <i>
8. <img>
9. <input>
10. <label>
11. <span>
12. <strong>
13. <sub>
14. <sup>
15. <time>

---


### **Inline-Block Elements Behave Like:**


 -Flow inline with other elements (like inline)
 - Accept width, height, padding, and margin values (like block)
 -Provide a hybrid behavior between block and inline elements.

- **Inline elements:**
  - Sit next to each other horizontally.
  - Do not automatically start on a new line.
  - Wrap to the next line if there‚Äôs no space, like words in a sentence.
  - Can be aligned with other inline or inline-block elements.

- **Block elements:**
  - Accept `width` and `height` values.
  - Allow `padding`, `margin`, and `border` on all sides.
  - You can fully control their box model properties.
  - Can start on a new line if forced (for example, using `<br>` or if there‚Äôs no space left in the container).
  - Behave like a box ‚Äî you decide its size and spacing.



### **Key Features of `inline-block`**

- √üinline-block elements can behave like inline elements, but you can also control their width, height, margins, and padding, like block elements
- Flows inline with other elements, like `inline`.
- Accepts `width`, `height`, `padding`, `margin`, and `border` values, like `block`.
- Provides a hybrid behavior between `block` and `inline` elements.
- Can wrap to the next line if there‚Äôs no space left on the current line.
- Can be aligned using the `vertical-align` property (like `top`, `middle`, `bottom`).



### **Common Examples**

- `<img>` elements (they‚Äôre `inline` by default, but behave like `inline-block` since they respect dimensions).
- `<button>` elements.
- Custom elements like `<div>`, `<li>`, or `<span>` when you set `display: inline-block` through CSS.




 ##Inline-Block Elements:
- Can start on a new line if forced.
- Width, height, margins, and padding can be set.
- Examples: `<div>`, `<p>`, `<li>`, `<img>` (when you want it to behave as a block).

Inline-block elements behave like:

- **Inline elements**: They sit next to each other horizontally.
- **Block elements**: They respect width and height properties and can have margins and padding.







================================================================================

specificity


CSS specificity is decides which style rules apply to an element 
when there are conflicting styles.

It determines which style wins out of multiple competing rules.



Universal Selector: 0
Element selectors and pseudo-elements: 1
Class selectors, attribute selectors, and pseudo-classes: 10
ID selectors: 100
Inline styles: 1000\
!import



Specificity in CSS refers to the set of rules that determine 
which style rule gets applied to an element 
when multiple conflicting rules exist




================================================================================

CSS selector can contain more than one simple selector. Between the simple selectors, we can include a combinator.

There are four different combinators in CSS:

descendant selector (space)
child selector (>)
adjacent sibling selector (+)
general sibling selector (~)




---------------------------------------------------------------
### Cascading (in CSS)

Cascading in CSS determines which styles are applied based on:

1. Source Order: Later styles override earlier ones.
2. Specificity: More specific selectors take precedence.
3. Importance: `!important` rules override others.
4. Inheritance: Some properties inherit values from parent elements.

### Example

css
p { color: blue; }           /* General */
.highlight p { color: red; } /* More specific */
p { color: green !important; } /* Highest priority */


### Summary
- Cascading: The method of applying CSS rules based on order, specificity, importance, and inheritance.


---------------------------------------------------------------------------------------------

### Elements


- Elements are the simplest building blocks of React applications.
- They describe what you want to see on the screen.
- They are used to define what the UI should look like.
- React elements are objects that describe a DOM node or part of the UI, not actual DOM nodes. They are descriptions of UI elements.
- Elements can contain:
  - Content: The actual data or text to be displayed.
  - Semantic meaning: Tags like `<header>`, `<footer>`, `<article>`, etc., provide structure and meaning to the UI.
  - Formatting instructions: Through attributes like `className` (CSS classes) or `style` (inline styles), React elements can specify how the content should be styled.
- React elements are immutable and lightweight objects that represent the structure of the UI.
- React uses these elements to create and update the DOM.



### Components

- Used to define the logic and structure of the UI, which can include multiple elements and other components.
- A function or class that can manage its own state and lifecycle.
- Components are more complex structures that define both the logic and structure of the UI, and they can include multiple elements and other components.
- A reusable and encapsulated piece of the UI, which can manage its own logic and state.

==============================================

### Tags

- Tags are the syntax used to create elements.
- A tag is a part of HTML syntax used to create an element.
- Tags can be opening, closing, or self-closing.

<div> <!-- Opening tag -->
</div> <!-- Closing tag -->

### Elements

- Elements are the structures that define the document's content and structure.
- An element consists of an opening tag, content (optional), and a closing tag.

<div> <!-- Opening tag -->
  This is a div element. <!-- Content -->
</div> <!-- Closing tag -->



========================================================================

 list of HTML5 features with just the titles:

1. Semantic Elements
2. Forms Enhancements
3. Canvas
4. Video and Audio
5. Offline Capabilities
6. Geolocation
7. Web Storage
8. Web Workers
9. SVG and MathML
10. Microdata
11. Drag and Drop API
12. WebSocket API
13. Server-Sent Events (SSE)
14. Viewport Meta Tag
15. Web Animation API
16. Custom Data Attributes
17. WebRTC
18. Form Validation
19. Shadow DOM
20. History API
21. Intersection Observer API
22. IndexedDB



1. **Semantic Elements**: 
HTML5 introduced new semantic elements like `<header>`, `<footer>`, `<article>`, and `<section>`, 
which provide more meaning to the structure of a webpage and improve accessibility.

2. **Forms Enhancements**: New input types (e.g., `email`, `date`, `number`) and 
attributes (e.g., `placeholder`, `required`) help create better forms and improve user experience and validation.

3. **Canvas**: The `<canvas>` element allows for dynamic, 
scriptable rendering of 2D shapes and bitmap images, useful for creating graphics and animations.

4. **Video and Audio**: The `<video>` and `<audio>` elements enable native embedding of media files without needing third-party plugins.

5. **Offline Capabilities**: HTML5 supports offline storage with the Application Cache (though now largely replaced by Service Workers) and local storage via `localStorage` and `sessionStorage`.

6. **Geolocation**: The Geolocation API allows websites to access the user's location, provided they give consent.

7. **Web Storage**: Local and session storage provide a way to store data on the client side, with improved capacity and easier access compared to cookies.

8. **Web Workers**: Web Workers allow scripts to run in background threads, enabling more complex computations without blocking the main thread and improving performance.

9. **SVG and MathML**: Support for Scalable Vector Graphics (SVG) and Mathematical Markup Language (MathML) allows for more detailed graphics and mathematical expressions directly in HTML.

10. **Microdata**: HTML5 introduced microdata for embedding machine-readable data within HTML documents, making it easier for search engines and other applications to interpret web content.

These features have helped make modern web applications more powerful, efficient, and interactive.




## HTML5 Features

### New Semantic Elements
- **Elements**: 
  - `<header>`: Defines a header for a document or section.
  - `<footer>`: Defines a footer for a document or section.
  - `<article>`: Represents a self-contained piece of content.
  - `<section>`: Defines a section in a document.
  - `<nav>`: Defines navigation links.
  - `<aside>`: Represents content aside from the main content.

### Form Enhancements
- **New Input Types**: `email`, `url`, `number`, `range`, `date`, `time`, etc.
- **Attributes**: 
  - `placeholder`: Displays a hint within an input field.
  - `required`: Specifies that an input field must be filled out.
  - `pattern`: Defines a regular expression for input validation.
- **Example**:
  ```html
  <input type="email" placeholder="Enter your email" required>
  ```

### Multimedia Support
- **Elements**: 
  - `<audio>`: Embeds sound content.
  - `<video>`: Embeds video content.
- **Attributes**: `controls`, `autoplay`, `loop`, `muted`.
- **Example**:
  ```html
  <video width="320" height="240" controls>
      <source src="movie.mp4" type="video/mp4">
      Your browser does not support the video tag.
  </video>
  ```

### Canvas Element
- **Purpose**: Used for drawing graphics via JavaScript.
- **Example**:
  ```html
  <canvas id="myCanvas" width="200" height="100"></canvas>
  <script>
      const canvas = document.getElementById('myCanvas');
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'red';
      ctx.fillRect(10, 10, 150, 100);
  </script>
  ```

### Geolocation API
- **Purpose**: Provides access to the user‚Äôs geographical location.
- **Example**:
  ```javascript
  if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(function(position) {
          console.log('Latitude: ' + position.coords.latitude);
          console.log('Longitude: ' + position.coords.longitude);
      });
  }
  ```

### Storage
- **Local Storage**: Stores data with no expiration time.
- **Session Storage**: Stores data for the duration of the page session.
- **Example**:
  ```javascript
  // Local Storage
  localStorage.setItem('key', 'value');
  console.log(localStorage.getItem('key')); // Outputs: value

  // Session Storage
  sessionStorage.setItem('key', 'value');
  console.log(sessionStorage.getItem('key')); // Outputs: value
  ```

### Web Workers
- **Purpose**: Allows running scripts in background threads.
- **Example**:
  ```javascript
  // worker.js
  onmessage = function(e) {
      postMessage('Hello ' + e.data);
  };

  // main.js
  const worker = new Worker('worker.js');
  worker.onmessage = function(e) {
      console.log(e.data); // Outputs: Hello [message]
 

 };
  worker.postMessage('World');
  ```

### WebSocket API
- **Purpose**: Provides full-duplex communication channels over a single TCP connection.
- **Example**:
  ```javascript
  const ws = new WebSocket('ws://www.example.com/socketserver');
  ws.onopen = function() {
      ws.send('Hello Server!');
  };
  ws.onmessage = function(event) {
      console.log('Message from server ', event.data);
  };
  ```

### Offline Web Applications
- **Application Cache**: Allows web applications to function offline (Note: deprecated in favor of Service Workers).

### Service Workers
- **Purpose**: Provides background functionality such as offline support and push notifications.
- **Example**:
  ```javascript
  if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
          .then(function(registration) {
              console.log('Service Worker registered with scope:', registration.scope);
          });
  }
  ```
  


==================================================================================



Cross-browser compatibility ensures that web applications work consistently across different browsers and versions, providing a uniform user experience. 

- **CSS Prefixes**: Use vendor prefixes (e.g., `-webkit-`, `-moz-`, `-ms-`, `-o-`) for CSS properties that require them to ensure compatibility with various browser engines.


==================================================================================

### Ways to Apply CSS in HTML:

1. **Inline CSS:**
   - Applied directly within an HTML element using the `style` attribute.
   - Example: `<h1 style="color: blue;">Heading</h1>`
   - **Use for**: Quick, single-element styling.

2. **Internal CSS:**
   - Defined within the `<style>` tag inside the `<head>` section.
   - Example: 
     ```html
     <style>
       h1 { color: blue; }
     </style>
     ```
   - **Use for**: Styling a single page.

3. **External CSS:**
   - external css by link tag add this tag in head section
   - Linked via a separate `.css` file using `<link>` in the `<head>` section.
   - Example: <link rel="stylesheet" type="text/css" href="styles.css">
   - **Use for**: Large projects with reusable styles.

   -  **rel and href are mandatory**.
    -**type is optional (modern browsers default to text/css)**



==========================================================================

CSS preprocessor

 CSS preprocessor is a tool that converts code written in its scripting language into standard CSS. This conversion makes CSS more powerful by providing features like:

- **Variables**
- **Nesting**
- **Mixins**
- **Functions**"

   These features help the development process, 
      reduce repetition,
     - Enhanced capabilities like **loops**, **functions**, and **conditionals**.
     - **Cleaner**, more modular code.
     - **Reusability** of code (via variables, mixins, etc.).
    - Improved **maintainability** and **organization** of styles.
    and make the CSS codebase easier to manage.



  -Variables :to store values (like colors, fonts, etc.) and reuse them throughout your stylesheet.
      - Example: `$primary-color: #3498db;`

  - Nesting :Lets you nest CSS selectors in a hierarchical structure, making the code more readable and maintainable.

  - Example:
      ```scss
      nav { ul { list-style-type: none; } }
      ```
  
  - Mixins :Reusable chunks of code that you can insert wherever needed, often with the ability to pass arguments to customize them.

    - Example:
      ```scss
      @mixin border-radius($radius) { border-radius: $radius; }
      .box { @include border-radius(10px); }
      ```

  - Functions :Let you define reusable logic (like mathematical operations) within your stylesheets

  - **Partials and Import**: Split CSS into smaller files and import them for better organization.
  - **Inheritance (Extends)**: Share styles between selectors to reduce redundancy.
    - Example: `.button { @extend .btn; }`

 
  

- **Popular CSS Preprocessors**:
  - **Sass** (with `.scss` and `.sass` syntax)
  - **LESS**
  - **Stylus**




================================================================================================================================================================



========================================================
classList

with help of classList JavaScript allows us to add, remove, replace, toggle or check whether the specified CSS class,s is present or not


add()	Adds one or more tokens to the list
contains()	Returns true if the list contains a class,s
remove()	Removes one or more tokens from the list
toggle()	Toggles between tokens in the list
replace()	Replaces a token in the list


    <style>
        .highlight {
            color: red;
        }
        .bold {
            font-weight: bold;
        }
    </style>
<body>
    <p id="text">Hello World</p>
    
    <button onclick="addClass()">Add Highlight</button>
    <button onclick="checkClass()">Check Highlight</button>
    <button onclick="removeClass()">Remove Highlight</button>
    <button onclick="toggleClass()">Toggle Highlight</button>
    <button onclick="replaceClass()">Replace Highlight with Bold</button>

    <script>
        function addClass() {
            document.getElementById('text').classList.add('highlight');
        }

        function checkClass() {
            const hasClass = document.getElementById('text').classList.contains('highlight');
            alert(hasClass ? 'Element has the highlight class!' : 'Element does not have the highlight class.');
        }

        function removeClass() {
            document.getElementById('text').classList.remove('highlight');
        }

        function toggleClass() {
            document.getElementById('text').classList.toggle('highlight');
        }

        function replaceClass() {
            document.getElementById('text').classList.replace('highlight', 'bold');
        }
    </script>
</body>
</html>



================================================================================


Flexbox:

One-dimensional layout model.
Best for arranging items in a row or a column.
Suited for smaller-scale layouts.
Controls alignment and distribution along a single axis.
Uses properties like display: flex, flex-direction, justify-content, and align-items.



CSS Grid:

Two-dimensional layout system.
Organizes content in rows and columns.
Ideal for larger-scale layouts.
Provides precise control over layout and placement of items
Utilizes properties like display: grid, grid-template-rows, and grid-template-columns.




================================================================================


Sure, let's compare Flexbox and CSS Grid across various aspects:

1.  ##Layout Model ##:
   - Flexbox: One-dimensional layout model.
   - CSS Grid: Two-dimensional layout system.

2.  ##Axis Control ##:
   - Flexbox: Controls layout along a single axis (either horizontally or vertically).
   - CSS Grid: Organizes content in rows and columns simultaneously.

3.  ##Suitability ##:
   - Flexbox: Best for smaller-scale layouts and components.
   - CSS Grid: Ideal for larger-scale layouts that are not linear in design.


7.  ##Usage ##:
- Flexbox: Commonly used for navigation menus, card layouts, and aligning content within containers.
- CSS Grid: Frequently used for complex page layouts, responsive grids, and magazine-style layouts.


4.  ##Alignment and Distribution ##:
   - Flexbox: Offers fine-tuning of alignment and space distribution between items.
   - CSS Grid: Provides precise control over layout and placement of items.

5.  ##Flexibility ##:
   - Flexbox: Works well for layouts with dynamic content and varying screen sizes.
   - CSS Grid: Offers flexibility with flexible widths and two-dimensional layout capabilities.

6.  ##Item Management ##:
   - Flexbox: Uses a parent-child relationship (Flex Container and Flex Item) to adjust item dimensions.
   - CSS Grid: Supports both implicit and explicit content placement, with built-in automation for extending line items.

In summary, Flexbox is well-suited for simpler layouts and alignment tasks, while CSS Grid excels in creating complex layouts with precise control over rows and columns. Both layout models have their strengths and are often used together to create highly customized and responsive web designs.



===============================================================================

What is the box model in CSS?

-The CSS box model is a fundamental concept 
that describes the layout and design of elements on a web page.
-The CSS box model is a way to understand how elements are structured on a web page.
-It consists of four main components: content, padding, border, and margin. 
- Content is what's inside the element,
 -padding is space around the content, 
 -border is a line around the padding, 
 -and margin is space outside the border. 





================================================================================

display none and visibility hidden

- **`visibility: hidden;`:**
           Hides the element while still occupying space in the layout.
             It's not visible, but it still affects the document flow.
- **`display: none;`:** 
         Completely removes the element from the layout, including its space. 
I         It's not rendered and doesn't affect the document flow.












