================================================================================
Semantic Elements

A semantic element clearly describes its meaning to both the browser and the developer.

Semantic elements in HTÃŸML provide meaning to the web content they enclose,
helping both browsers and developers understand the structure and purpose of the content.
They improve accessibility, SEO, and maintainability of web pages.

Key Features:
Meaningful Structure: Conveys the role of the content.
Improved Accessibility: Aids assistive technologies in navigating content.
SEO Benefits: Helps search engines better index and rank pages.
Common Semantic Elements:

<article>
<aside>
<details>
<figcaption>
<figure>
<footer>
<header>
<main>
<mark>
<nav>
<section>
<summary>
<time>
================================================================================
 What is memoization in JavaScript?

Memoization is an optimization technique used primarily to speed up computer programs
by storing the results of expensive function calls
and returning the cached result when the same inputs occur again.

It is particularly useful for functions with expensive or repetitive computations.

================================================================================
What are generators in JavaScript?

Generators are special types of functions that can be paused and resumed,
allowing for control over the function's execution.

They are defined using the function\* syntax and use the yield keyword to pause execution.

The main method of a generator is next()

The result of next() is always an object with two properties:

value: the yielded value.
done: true if the function code has finished, otherwise false.

 <!-- next() method in a generator is used to resume the generator's execution and obtain the next value from the sequence. Each call to next() returns an object with two properties:

value: The value yielded by the generator.
done: A boolean indicating if the generator has completed execution (true if finished, false otherwise). -->

function\* generatorExample() {
yield 1;
yield 2;
yield 3;
}

const gen = generatorExample();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

================================================================================

Immediately Invoked Function Expression (IIFE)

An IIFE is a function that is executed immediately after it is defined.
It is often used to create a local scope to avoid polluting the global scope.

(function() {
console.log("This function runs immediately!");
})();

(function(name) {
console.log("Hello, " + name + "!");
})("World");



Encapsulation: Creates private scopes for variables and functions, preventing conflicts and unintended modifications in the global scope.

Avoiding Global Pollution: Keeps the global namespace clean, minimizing naming clashes with other scripts or libraries and maintaining modular, self-contained code.

Immediate Execution: Runs code immediately after declaration, useful for initialization tasks, configuring settings, or starting applications at the desired moment.

Data Privacy: Utilizes closures to maintain data privacy, hiding internal variables and functions while exposing only necessary parts, fundamental to the Module Pattern.


================================================================================

What are iterators in JavaScript?

Answer: Iterators are objects that enable traversal through a collection of data,
such as arrays or strings. They provide a standardized way to loop through elements by
implementing a specific interface with a `next` method that returns an object
with two properties: `value` and `done`.

Example:

// Example of an iterator using an array
const array = [1, 2, 3];

const iterator = array[Symbol.iterator]();

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }

// Creating a custom iterator
function makeIterator(array) {
let index = 0;
return {
next: function() {
if (index < array.length) {
return { value: array[index++], done: false };
} else {
return { value: undefined, done: true };
}
}
};
}

const customIterator = makeIterator([10, 20, 30]);

console.log(customIterator.next()); // { value: 10, done: false }
console.log(customIterator.next()); // { value: 20, done: false }
console.log(customIterator.next()); // { value: 30, done: false }
console.log(customIterator.next()); // { value: undefined, done: true }


================================================================================

What are PropTypes?
PropTypes is a type-checking library included with React.
It allows you to specify the expected types for props that a component should receive, providing runtime type validation.

npm install prop-types

================================================================================

In React, a ref (short for reference) is an object that allows you to directly access and interact with a DOM element

================================================================================

whats forwardref react

forwardRef in React is a utility that allows you to pass a ref from a parent component to a child component.
This is useful when you want to access a DOM element

When to Use Refs
Accessing DOM Elements: When you need to directly interact with a DOM element.
Managing Focus: To control focus on inputs or buttons.
Animations: For triggering animations in response to user interactions.
Third-Party Libraries: When integrating with libraries that manipulate the DOM directly.

import React, { useRef, forwardRef } from 'react';

// Child component using forwardRef
const CustomInput = forwardRef((props, ref) => {
return <input ref={ref} type="text" {...props} />;
});

// Parent component
const App = () => {
const inputRef = useRef(null);

const focusInput = () => {
if (inputRef.current) {
inputRef.current.focus(); // Focus the input element
}
};

return (
<div>
<CustomInput ref={inputRef} placeholder="Type something..." />
<button onClick={focusInput}>Focus Input</button>
</div>
);
};

export default App;

================================================================================

### Axios

- Popular Promise-based HTTP client for making AJAX requests in the browser and Node.js.
- Interceptors for request and response handling.
- Automatic transformation of JSON data.
- Support for browser and Node.js environments.
- Ability to cancel requests.
- CSRF protection by default.
- Error handling with meaningful error messages.
- Interceptors provide global request/response handling.

### Fetch

- Modern API for making network requests in the browser, built into modern browsers (ES6 feature).
- Promise-based API.
- Streamlined API surface compared to XMLHttpRequest (XHR).
- No third-party dependencies.
- Support for streaming responses.

### Use Axios If:

- You need built-in support for interceptors, request cancellation, or automatic JSON parsing.
- Cross-browser compatibility is important, including older browsers.
- You prefer simplified error handling and configuration.

### Use Fetch If:

- You want to avoid additional dependencies and rely on native browser APIs.
- Performance and bundle size are critical, especially in modern environments.
- You are comfortable handling request/response interception and additional error handling manually.

This format highlights the specific reasons and scenarios where Axios or Fetch would be preferred based on their capabilities and characteristics.

====================================================================================

Q15 is the Shadow DOM the same as the Virtual DOM?
-No, they are different.

-The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in
web components.

- This is a browser technology designed primarily for encapsulating and scoping variables, DOM, and CSS within web components.
- It allows you to create self-contained components with their own DOM structure and styling, isolated from the rest of the document.

====================================================================================

### Elements

- Elements are the simplest building blocks of React applications and
 describe what you want to see on the screen.
- A basic building block representing a DOM node.
- Used to describe what the UI should look like.
- A plain object representing a DOM node.

### Components

- Used to define the logic and structure of the UI, which can include multiple elements and other components.
- A function or class that can manage its own state and lifecycle.
- Components are more complex structures that define both the logic and structure of the UI, and they can include multiple elements and other components.
- A reusable and encapsulated piece of the UI, which can manage its own logic and state.

====================================================================================

### Tags

- Tags are the syntax used to create elements.
- A tag is a part of HTML syntax used to create an element.
- Tags can be opening, closing, or self-closing.

<div> <!-- Opening tag -->
</div> <!-- Closing tag -->

### Elements

- Elements are the structures that define the document's content and structure.
- An element consists of an opening tag, content (optional), and a closing tag.

<div> <!-- Opening tag -->
  This is a div element. <!-- Content -->
</div> <!-- Closing tag -->

<!--

Tags are the syntax used to create elements.
A tag is a part of HTML syntax used to create an element.
A tag is a single component of an element.
Tags are used to create elements.
Tags can be opening, closing, or self-closing.


Elements are the structures that define the document's content and structure.
An element consists of an opening tag, content (optional), and a closing tag.
Elements define the structure and content of a web page. -->

====================================================================================
Patch vs Put

- **PUT**

  - The PUT method is used to update an entire resource.
  - If the resource exists, it will be completely replaced with the new data provided.
  - PUT replaces the entire resource.
  - If your form or component allows the user to update an entire resource (e.g., editing all fields of a user profile), you might use PUT.

- **PATCH**
  - The PATCH method is used to apply partial updates to a resource.
  - This means you only send the fields you want to update, and the rest of the resource remains unchanged.
  - PATCH updates only the specified fields.
  - If your form or component allows the user to update only specific fields (e.g., changing the user's email address or password), you might use PATCH.

====================================================================================

### Multipage Application (MPA)

- Uses separate HTML pages for different content.
- Requires full page reloads when navigating between pages.
- Fetches content from the server for each page.
- Better for content-heavy websites and SEO.
- Slower navigation and higher bandwidth usage.

### Single Page Application (SPA)

- Loads content dynamically on a single page.
- Uses client-side routing for smooth navigation.
- Fetches data initially; subsequent interactions are handled locally.
- Ideal for interactive and responsive applications.
- Initial load may be slower, but faster interactions afterward.

### A) Multipage Application (MPA)

- **Definition**: An application/website with multiple requestable web pages is called a multipage application.
- **Content Fetching**: Different content requires fetching different web pages from the server.
- **Performance**: Multipage applications can be slower because each request is sent to the server, and the server returns a web page as a response.
- **Server Resources**: Utilizes server resources for each request, often requiring high-configuration servers.
- **Bandwidth**: Uses more bandwidth as each page load requires a full page download.
- **DOM Recreation**: Recreates the DOM for each request.

- Load all content in a single HTML page.
- Dynamically update content using JavaScript frameworks like React or Angular.
- Enable smoother user experiences by avoiding full page reloads.
- May have slower initial load times due to loading all resources upfront.
- Suitable for complex web applications with frequent user interactions.

### B) Single Page Application (SPA)

- **Definition**: An application with a single requestable web page is called a single page application.
- **Content Loading**: In SPAs, all the content is loaded in the web browser on the first request. Subsequent requests are handled by the browser.
- **Server Resources**: Does not utilize server resources for each request because the content is served from the web browser.
- **Bandwidth**: Requires less bandwidth since the initial load fetches the full application, and subsequent interactions are handled client-side.
- **Performance**: Slow for the first request due to the initial load but fast for subsequent requests.

- Consist of multiple HTML pages, each loaded separately from the server.
- Require full page reloads when navigating between pages.
- Generally simpler to build and maintain compared to SPAs.
- Often faster to load because only necessary content for each page is loaded.
- Better suited for content-driven websites with less interactivity.
====================================================================================


why  const varible array/object can be changed in javascript

-const keyword is used to declare variables whose values cannot be reassigned.


=================================================================================================================

-A lexical scope in JavaScript means that a variable defined outside a function can be accessible inside another function

Function Scope:
Each function in JavaScript creates a new scope. Variables defined within a function are not accessible outside of it.

Block Scope:
Variables declared with let and const are block-scoped, meaning they are only accessible within the nearest set of curly braces {} in which they are defined.

Nested Scopes:
Inner functions have access to variables and functions in their outer scopes. This nesting can continue indefinitely, allowing inner functions to access variables from all outer scopes up to the global scope.

function outerFunction() {
  var outerVar = 'I am outside!';

  function innerFunction() {
    var innerVar = 'I am inside!';
    console.log(outerVar); // Accessible
    console.log(innerVar); // Accessible
  }

  innerFunction();
  console.log(outerVar); // Accessible
  // console.log(innerVar); // Uncaught ReferenceError: innerVar is not defined
}

outerFunction();
